[{"title":"天使投资、VC、PE 的区别","date":"2017-11-06T11:52:55.000Z","path":"2017/11/06/天使投资、VC、PE 的区别/","text":"简单来说，天使／VC／PE属于私募基金，体现了企业从创业初期到IPO之前的整个融资过程，属于一级市场，到公司上市后，企业走向二级市场，叫做公开募股，先看图： 1）先从公司创业期的融资说起：一般来说，我们经常听到的就是风险投资（Venture Capital，简称为VC）和天使。天使：企业刚刚开始创立，进来的是天使。这个阶段，大多企业基本还是赔钱的。VC：传统来说，这也基本已经盈利了，才会引入VC，但现在好的项目也不一定，例如近期的知乎和摩拜。因此，当前阶段还是有一定风险的。所以叫风险投资。该过程可能有多轮，也就是我们常听的A轮、B轮、C轮和D轮，每轮可能有一个领投，多个跟投。 2）上市前的融资：企业上市，也就是IPO（暂且先这样理解），这个阶段经常听到的是私募股权投资Private Equity，简称为PE。上市代表有巨大盈利空间，这个阶段的PE可以说是来分蛋糕的，也叫Pre-IPO。对投资方来说，此时的投资有一定保障，但不代表没有风险。 3）上市后的融资：公司上市，也叫IPO，即首次公开募股Initial Public Offerings（IPO）指企业通过证券交易所首次公开向投资者增发股票，以期募集用于企业发展资金的过程。股票上市后融资差不多就是在二级市场交易了，但也不排除一级市场。 补充：","tags":[{"name":"金融","slug":"金融","permalink":"http://www.hansam.cc/tags/金融/"}]},{"title":"javascript 基础 js类和原型","date":"2017-08-09T14:28:40.000Z","path":"2017/08/09/javascript 基础 js 类和原型/","text":"&emsp; 一个函数可以看成一个类，原型是所有类都有的一个属性，原型的作用就是给这个类的每一个对象都添加一个统一的方法。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type = \"text/javascript\"&gt; //声明一个类 function Person(name,age) &#123; this.name=name; this.age=age; &#125; //使用原型给类添加方法 Person.prototype.show=function() &#123; alert(\"我叫\"+this.name+\",今年\"+this.age); &#125; //创建两个对象 var person1 =new Person('张三',20); var person2 =new Person('李四',23); //调用原型里面的方法 person1.show(); person2.show(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.hansam.cc/tags/JavaScript/"}]},{"title":"Java中的数字格式化类DecimalFormat","date":"2017-08-08T14:24:03.000Z","path":"2017/08/08/Java中的数字格式化类DecimalFormat/","text":"&emsp; 我们经常要将数字进行格式化，比如取2位小数，这是最常见的。Java 提供 DecimalFormat类，帮你用最快的速度将数字格式化为你需要的样子。下面是一个例子： 12345678910111213141516171819202122232425262728import java.text.DecimalFormat; public class TestNumberFormat&#123; public static void main(String[] args)&#123; double pi=3.1415927; //圆周率 //取一位整数 System.out.println(new DecimalFormat(\"0\").format(pi)); //3 //取一位整数和两位小数 System.out.println(new DecimalFormat(\"0.00\").format(pi)); //3.14 //取两位整数和三位小数，整数不足部分以0填补。 System.out.println(new DecimalFormat(\"00.000\").format(pi));// 03.142 //取所有整数部分 System.out.println(new DecimalFormat(\"#\").format(pi)); //3 //以百分比方式计数，并取两位小数 System.out.println(new DecimalFormat(\"#.##%\").format(pi)); //314.16% long c=299792458; //光速 //显示为科学计数法，并取五位小数 System.out.println(new DecimalFormat(\"#.#####E0\").format(c)); //2.99792E8 //显示为两位整数的科学计数法，并取四位小数 System.out.println(new DecimalFormat(\"00.####E0\").format(c)); //29.9792E7 //每三位以逗号进行分隔。 System.out.println(new DecimalFormat(\",###\").format(c)); //299,792,458 //将格式嵌入文本 System.out.println(new DecimalFormat(\"光速大小为每秒,###米。\").format(c)); &#125;&#125; DecimalFormat 类主要靠 # 和 0 两种占位符号来指定数字长度。0 表示如果位数不足则以 0 填充，# 表示只要有可能就把数字拉上这个位置。上面的例子包含了差不多所有的基本用法，如果你想了解更多，请参考 DecimalFormat 类的文档。","tags":[]},{"title":"简述负载均衡和CDN技术","date":"2017-08-07T14:17:12.000Z","path":"2017/08/07/简述负载均衡和CDN技术/","text":"&emsp;曾经见到知乎上有人问“为什么像facebook这类的网站需要上千个工程师维护？”，下面的回答多种多样，但总结起来就是：一个高性能的web系统需要从无数个角度去考虑他，大到服务器的布局，小到软件中某个文件的实现，甚至于某个循环内的运算如果出现不严谨都可能导致全盘崩溃。 &emsp;上面提到web性能优化需要多个角度去考虑，我们无法考虑到所有的优化细节，但可以从我们已知的层面去优化，我们就先从网络层面说起。 网络请求路径:（客户端输入URL定位符）→（DNS服务器寻找映射）→（进入服务器，处理数据）→（返回数据至客户端） 在这个用例中我们可以很清晰的看出网络请求到返回的过程，虽然非常抽象，但足够我们以他为基础来进行优化了。 1.负载均衡&emsp;BOSS一次给了小明好多项任务，小明发现怎么安排时间也做不完，于是乎他盯上了在旁边偷偷看电影的小强，小强突然觉得背后有一股凉气，一回头小明一脸坏笑看着他，“这几个任务交给你，晚上请你吃饭，要不然…嘿嘿嘿”，小强虽然不情愿，但是在小明的请求（要挟）下，只能服从。第二天，小明顺利的完成了任务，给小强买了袋辣条。 &emsp;在计算机上负载均衡也类似如此，我们的大BOSS客户端将请求发送至服务器，然而一台服务器是无法承受很高的并发量的，我们就会将请求转发到其他服务器，当然真正的负载均衡架构并不是由一台server转发的另一台server，而在客户端与服务器端中间加入了一个负责分配请求的负载均衡硬件（软件）。 DNS&emsp;名词：DNS是客户端发送请求中一个非常重要的中转，他的作用是将用户请求的URL映射为具体的IP地址，全世界有13台根服务器，但通常为我们进行域名解析的并不是根服务器，而是直接访问我们的 LDNS（Local DNS Server），通常由网络运营商维护。 &emsp;最早的负载均衡就是利用搭建本地DNS服务器实现的，实现方式简单易懂，为同一个主机名分配多个映射，可采用轮循，随机等方式分配请求。看上去没什么问题，但是在使用过程中会发现，如果其中一个地址down机，我们是无法及时发现的，如果有用户被分配到这个主机就会出现访问失败的状况，同时我们也无法判断每个server的负载，可能会出现，某个server几乎闲置，另外一个server负载压力极高的情况。 硬件设备&emsp;名词：负载均衡器（Load Balancer），负载均衡器通常作为独立的硬件置于客户端与服务器之间。 &emsp;负载均衡设备拥有非常好的负载均衡性能，他拥有众多的负载均衡策略（权重，动态比率，最快模式，最小连接数等），可以保证以相对较优的方式分配请求，不过好的东西总是有代价的，那就是价格，一台负载均衡器的售价往往高达十几万甚至几十万，许多企业并不愿意为它买单。 反向代理&emsp;名词：Nginx。高性能，轻量级，已经成了人们对Nginx的第一印象，Nginx可作为HTTP服务器，在处理高并发请求的时候拥有比现在主流的Apache服务器更高的性能，同时Nginx也是一个优秀的反向代理服务器。 &emsp;第一次听到“反向代理”，可能有些陌生，但如果了解与之对应的正向代理就很好理解了，正向代理通常由客户端主动链接，比如我们的科学上网方式就是使用正向代理，以达到间接访问网站的目的，而反向代理在服务器端，无需主动链接，当我们访问拥有反向代理的网站时，实际访问的是其反向代理服务器，而非真正的服务器，当请求到达反向代理服务器时，反向代理服务器再将请求转发至服务器。反向代理是实现负载均衡的主流手段之一，通常使用Nginx等服务器搭建，Nginx同样拥有众多的分配策略，以保证平均分配压力。 Nginx反向代理 BIGIP（硬件）负载均衡 2.CDN&emsp;视频总在缓冲，图片各种加载不出来，几年前是再正常不过的事了，在当时大家也没觉得是回事，但把这种情况放在现在，我想人们绝对直接就小红叉了吧，那么我们如何避免这样的情况呢？这就是我要说的，内容分发网络（Content Delivery Network），简称：CDN。 &emsp;CDN简单的来说就是存储一些静态文件的一台或多台服务器，通过复制，缓存等方式，将文件保存其中。 1.哪些是静态文件？ css，html，图片，媒体都属于静态文件，也就是说用户发送的请求不会影响静态文件的内容，而jsp，php等文件就不属于静态文件，因为他们的内容会因我们的请求而发生改变。 2.CDN如何实现加速？ 通常情况下，我们所要的数据都是从主服务器中获取，但假如我们的主服务器在南方，而访问用户在北方，那么访问速度就会相对变慢，变慢的原因有很多，例如传输距离，运营商，带宽等等因素，而使用CDN技术的话，我们会将CDN节点分布在各地，当用户发送请求到达服务器时，服务器会根据用户的区域信息，为用户分配最近的CDN服务器。 3.CDN数据从哪里来？ 复制，缓存，CDN服务器可以在用户请求后缓存文件，也可以主动抓取主服务器内容。 分布在各地的CDNS： 原文引用：http://www.cnblogs.com/mokafamily/p/4402366.html","tags":[{"name":"架构","slug":"架构","permalink":"http://www.hansam.cc/tags/架构/"}]},{"title":"反向代理与正向代理区别","date":"2017-07-30T02:46:07.000Z","path":"2017/07/30/反向代理与正向代理区别/","text":"什么是代理 &emsp;代理（英语：Proxy），也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。&emsp;提供代理服务的电脑系统或其它类型的网络终端称为代理服务器（英文：Proxy Server）。 正向代理 &emsp;A同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。 &emsp;我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 http://www.google.com 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。 反向代理 &emsp;大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理。客户不知道真正提供服务人的是谁。 &emsp;反向代理隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。","tags":[{"name":"系统架构","slug":"系统架构","permalink":"http://www.hansam.cc/tags/系统架构/"}]},{"title":"WebService服务的使用","date":"2017-07-30T02:19:39.000Z","path":"2017/07/30/WebService服务的使用/","text":"使用wsimport生成客户端java类 wsimport -keep -p cc http://192.168.1.124:1533/ws/shi?wsdl 使用生成的客户端调用服务12345678910111213141516171819202122232425262728293031323334353637&lt;definitions xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" xmlns:wsp=\"http://www.w3.org/ns/ws-policy\" xmlns:wsp1_2=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" xmlns:wsam=\"http://www.w3.org/2007/05/addressing/metadata\" xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" xmlns:tns=\"http://support.ws.integration.server.odb.product.uinnova.com/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"http://schemas.xmlsoap.org/wsdl/\" targetNamespace=\"http://support.ws.integration.server.odb.product.uinnova.com/\" name=\"WSServiceImplService\"&gt;&lt;types&gt;&lt;xsd:schema&gt;&lt;xsd:import namespace=\"http://support.ws.integration.server.odb.product.uinnova.com/\" schemaLocation=\"http://192.168.1.124:1533/ws/shi?xsd=1\"/&gt;&lt;/xsd:schema&gt;&lt;/types&gt;&lt;message name=\"call\"&gt;&lt;part name=\"parameters\" element=\"tns:call\"/&gt;&lt;/message&gt;&lt;message name=\"callResponse\"&gt;&lt;part name=\"parameters\" element=\"tns:callResponse\"/&gt;&lt;/message&gt;&lt;portType name=\"WSServiceImpl\"&gt;&lt;operation name=\"call\"&gt;&lt;input wsam:Action=\"http://support.ws.integration.server.odb.product.uinnova.com/WSServiceImpl/callRequest\" message=\"tns:call\"/&gt;&lt;output wsam:Action=\"http://support.ws.integration.server.odb.product.uinnova.com/WSServiceImpl/callResponse\" message=\"tns:callResponse\"/&gt;&lt;/operation&gt;&lt;/portType&gt;&lt;binding name=\"WSServiceImplPortBinding\" type=\"tns:WSServiceImpl\"&gt;&lt;soap:binding transport=\"http://schemas.xmlsoap.org/soap/http\" style=\"document\"/&gt;&lt;operation name=\"call\"&gt;&lt;soap:operation soapAction=\"\"/&gt;&lt;input&gt;&lt;soap:body use=\"literal\"/&gt;&lt;/input&gt;&lt;output&gt;&lt;soap:body use=\"literal\"/&gt;&lt;/output&gt;&lt;/operation&gt;&lt;/binding&gt;&lt;service name=\"WSServiceImplService\"&gt;&lt;port name=\"WSServiceImplPort\" binding=\"tns:WSServiceImplPortBinding\"&gt;&lt;soap:address location=\"http://192.168.1.124:1533/ws/shi\"/&gt;&lt;/port&gt;&lt;/service&gt;&lt;/definitions&gt; 调用 123456789101112131415161718192021package cc.hansam.java.net.ws.odb;/** * 通过wsimport生成的客户端代码调用webservice服务 * * @author hansam 945210972@qq.com * @date 2017年7月24日下午3:03:19 */public class App &#123; public static void main(String[] args) &#123; WSServiceImplService service = new WSServiceImplService(); WSServiceImpl po = service.getWSServiceImplPort(); String call = po.call(\"\"); System.out.println(call); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"}]},{"title":"Java Socket编程","date":"2017-07-22T15:34:51.000Z","path":"2017/07/22/Java-Sockett编程/","text":"Java最初是作为网络编程语言出现的，其对网络提供了高度的支持，而在网络编程中，使用最多的就是Socket。QQ、MSN都使用了Socket相关的技术。 一、计算机网络基础1. 两台计算机间进行通讯需要以下三个条件 ip地址、协议、端口号 2. TCP/IP协议 是以TCP和IP为基础的不同层次上多个协议的集合，也称TCP/IP协议族、或TCP/IP协议栈TCP：Transmission Control Protocol 传输控制协议IP：Internet Protocol 互联网协议 3. TCP/IP五层模型 应用层运输层网络层数据链路层物理层 4. IP地址 为实现网络中不同计算机之间的通信，每台计算机都必须有一个唯一的标识(32bit)。 5. 端口 区分一台主机的多个不同应用程序，端口号范围为0-65535，其中0-1023位为系统保留。如：HTTP：80FTP：21 Telnet：23IP地址+端口号组成了所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点，是TCP和UDP的基础 6. Socket套接字 IP地址+端口,组合在一起才能构成唯一能识别的标识符套接字Socket原理机制：通信的两端都有Socket网络通信其实就是Socket间的通信数据在两个Socket间通过IO传输 7. Java中的网络支持 针对网络通信的不同层次，Java提供了不同的API，其提供的网络功能有四大类：InetAddress:用于标识网络上的硬件资源，主要是IP地址URL：统一资源定位符，通过URL可以直接读取或写入网络上的数据Sockets：使用TCP协议实现的网络通信Socket相关的类Datagram:使用UDP协议，将数据保存在用户数据报中，通过网络进行通信。 二、InetAddress InetAddress类用于标识网络上的硬件资源，标识IP地址。该类没有构造方法123456789//获取本机的InetAddress实例 InetAddress address =InetAddress.getLocalHost(); address.getHostName();//获取计算机名 address.getHostAddress();//获取IP地址 byte[] bytes = address.getAddress();//获取字节数组形式的IP地址,以点分隔的四部分 //获取其他主机的InetAddress实例 InetAddress address2 =InetAddress.getByName(\"其他主机名\"); InetAddress address3 =InetAddress.getByName(\"IP地址\"); 三、URL类12345678910//创建一个URL的实例 URL baidu =new URL(\"http://www.baidu.com\"); URL url =new URL(baidu,\"/index.html?username=tom#test\");//？表示参数，#表示锚点 url.getProtocol();//获取协议 url.getHost();//获取主机 url.getPort();//如果没有指定端口号，根据协议不同使用默认端口。此时getPort()方法的返回值为 -1 url.getPath();//获取文件路径 url.getFile();//文件名，包括文件路径+参数 url.getRef();//相对路径，就是锚点，即#号后面的内容 url.getQuery();//查询字符串，即参数 使用URL读取网页内容 通过URL对象的openStream()方法可以得到指定资源的输入流，通过流能够读取或访问网页上的资源1234567891011121314//使用URL读取网页内容 //创建一个URL实例 URL url =new URL(\"http://www.baidu.com\"); InputStream is = url.openStream();//通过openStream方法获取资源的字节输入流 InputStreamReader isr =newInputStreamReader(is,\"UTF-8\");//将字节输入流转换为字符输入流,如果不指定编码，中文可能会出现乱码 BufferedReader br =newBufferedReader(isr);//为字符输入流添加缓冲，提高读取效率 String data = br.readLine();//读取数据 while(data!=null)&#123; System.out.println(data);//输出数据 data = br.readerLine(); &#125; br.close(); isr.colose(); is.close(); 四、TCP编程1. TCP协议 是面向连接的、可靠的、有序的、以字节流的方式发送数据，通过三次握手方式建立连接，形成传输数据的通道，在连接中进行大量数据的传输，效率会稍低。 2. Java中基于TCP协议实现网络通信的类 客户端的Socket类服务器端的ServerSocket类 3. Socket通信的步骤 ① 创建ServerSocket和Socket② 打开连接到Socket的输入/输出流③ 按照协议对Socket进行读/写操作④ 关闭输入输出流、关闭Socket 4. 服务器端 ① 创建ServerSocket对象，绑定监听端口② 通过accept()方法监听客户端请求③ 连接建立后，通过输入流读取客户端发送的请求信息④ 通过输出流向客户端发送乡音信息⑤ 关闭相关资源123456789101112131415161718192021222324252627282930/** 基于TCP协议的Socket通信，实现用户登录，服务端 */ //1、创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并监听此端口 ServerSocket serverSocket =newServerSocket(10086);//1024-65535的某个端口 //2、调用accept()方法开始监听，等待客户端的连接 Socket socket = serverSocket.accept(); //3、获取输入流，并读取客户端信息 InputStream is = socket.getInputStream(); InputStreamReader isr =newInputStreamReader(is); BufferedReader br =newBufferedReader(isr); String info =null; while((info=br.readLine())!=null)&#123; System.out.println(\"我是服务器，客户端说：\"+info)； &#125; socket.shutdownInput();//关闭输入流 //4、获取输出流，响应客户端的请求 OutputStream os = socket.getOutputStream(); PrintWriter pw = new PrintWriter(os); pw.write(\"欢迎您！\"); pw.flush(); //5、关闭资源 pw.close(); os.close(); br.close(); isr.close(); is.close(); socket.close(); serverSocket.close(); 5. 客户端 ① 创建Socket对象，指明需要连接的服务器的地址和端口号② 连接建立后，通过输出流想服务器端发送请求信息③ 通过输入流获取服务器响应的信息④ 关闭响应资源1234567891011121314151617181920212223//客户端 //1、创建客户端Socket，指定服务器地址和端口 Socket socket =newSocket(\"localhost\",10086); //2、获取输出流，向服务器端发送信息 OutputStream os = socket.getOutputStream();//字节输出流 PrintWriter pw =newPrintWriter(os);//将输出流包装成打印流 pw.write(\"用户名：admin；密码：123\"); pw.flush(); socket.shutdownOutput(); //3、获取输入流，并读取服务器端的响应信息 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String info = null; while((info=br.readLine())!null)&#123; System.out.println(\"我是客户端，服务器说：\"+info); &#125; //4、关闭资源 br.close(); is.close(); pw.close(); os.close(); socket.close(); 6. 应用多线程实现服务器与多客户端之间的通信 ① 服务器端创建ServerSocket，循环调用accept()等待客户端连接② 客户端创建一个socket并请求和服务器端连接③ 服务器端接受苦读段请求，创建socket与该客户建立专线连接④ 建立连接的两个socket在一个单独的线程上对话⑤ 服务器端继续等待新的连接123456789101112131415161718192021222324//服务器线程处理 //和本线程相关的socket Socket socket =null; // public serverThread(Socket socket)&#123; this.socket = socket; &#125; publicvoid run()&#123; //服务器处理代码 &#125; //============================================ //服务器代码 ServerSocket serverSocket =newServerSocket(10086); Socket socket =null; int count =0;//记录客户端的数量 while(true)&#123; socket = serverScoket.accept(); ServerThread serverThread =newServerThread(socket); serverThread.start(); count++; System.out.println(\"客户端连接的数量：\"+count); &#125; 五、UDP编程 UDP协议（用户数据报协议）是无连接的、不可靠的、无序的,速度快进行数据传输时，首先将要传输的数据定义成数据报（Datagram），大小限制在64k，在数据报中指明数据所要达到的Socket（主机地址和端口号），然后再将数据报发送出去。DatagramPacket类:表示数据报包DatagramSocket类：进行端到端通信的类 1. 服务器端实现步骤 ① 创建DatagramSocket，指定端口号② 创建DatagramPacket③ 接受客户端发送的数据信息④ 读取数据12345678910111213141516171819202122232425//服务器端，实现基于UDP的用户登录 //1、创建服务器端DatagramSocket，指定端口 DatagramSocket socket =new datagramSocket(10010); //2、创建数据报，用于接受客户端发送的数据 byte[] data =newbyte[1024];// DatagramPacket packet =newDatagramPacket(data,data.length); //3、接受客户端发送的数据 socket.receive(packet);//此方法在接受数据报之前会一致阻塞 //4、读取数据 String info =newString(data,o,data.length); System.out.println(\"我是服务器，客户端告诉我\"+info); //========================================================= //向客户端响应数据 //1、定义客户端的地址、端口号、数据 InetAddress address = packet.getAddress(); int port = packet.getPort(); byte[] data2 = \"欢迎您！\".geyBytes(); //2、创建数据报，包含响应的数据信息 DatagramPacket packet2 = new DatagramPacket(data2,data2.length,address,port); //3、响应客户端 socket.send(packet2); //4、关闭资源 socket.close(); 2. 客户端实现步骤 ① 定义发送信息② 创建DatagramPacket，包含将要发送的信息③ 创建DatagramSocket④ 发送数据123456789101112131415161718192021222324//客户端 //1、定义服务器的地址、端口号、数据 InetAddress address =InetAddress.getByName(\"localhost\"); int port =10010; byte[] data =\"用户名：admin;密码：123\".getBytes(); //2、创建数据报，包含发送的数据信息 DatagramPacket packet = newDatagramPacket(data,data,length,address,port); //3、创建DatagramSocket对象 DatagramSocket socket =newDatagramSocket(); //4、向服务器发送数据 socket.send(packet); //接受服务器端响应数据 //====================================== //1、创建数据报，用于接受服务器端响应数据 byte[] data2 = new byte[1024]; DatagramPacket packet2 = new DatagramPacket(data2,data2.length); //2、接受服务器响应的数据 socket.receive(packet2); String raply = new String(data2,0,packet2.getLenth()); System.out.println(\"我是客户端，服务器说：\"+reply); //4、关闭资源 socket.close(); 六、注意问题1. 多线程的优先级问题 根据实际的经验，适当的降低优先级，否侧可能会有程序运行效率低的情况 2. 是否关闭输出流和输入流 对于同一个socket，如果关闭了输出流，则与该输出流关联的socket也会被关闭，所以一般不用关闭流，直接关闭socket即可 3. 使用TCP通信传输对象，IO中序列化部分4. Socket编程传递文件，IO流部分","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"}]},{"title":"java特殊注释","date":"2017-07-18T15:01:13.000Z","path":"2017/07/18/java特殊注释/","text":"java中的特殊注释： 1. TODO 表示需要实现，但目前还未实现的功能 2. XXX 勉强可以工作，但是性能差等原因 3. FIXME 代码是错误的，不能工作，需要修复 TODO: + 说明： 如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。 FIXME: + 说明： 如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。 XXX: + 说明： 如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。 eclipse中特殊的注释： 在eclipse中，TODO、FIXME和XXX都会被eclipse的task视图所收集。在项目发布前，检查一下task视图是一个很好的习惯。此外，在eclipse中，我们可自定义自己的特殊注释标签。如在Java中，进入123A[Windows] --&gt; B[Java] B --&gt; C[Compiler]C --&gt; D[Task Tags] 窗口即可添加特殊标签，默认只有TODO、FIXME和XXX。","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"},{"name":"笔记","slug":"笔记","permalink":"http://www.hansam.cc/tags/笔记/"}]},{"title":"fastjson基础测试","date":"2017-07-17T14:57:53.000Z","path":"2017/07/17/fastjson基础测试/","text":"fastjson使用测试 12345678910111213141516171819202122232425262728293031323334353637383940package cc.hansam.mystudy.json;import java.util.Map;import com.alibaba.fastjson.JSON;/** * @author hansam 945210972@qq.com * @date 2017年7月17日下午4:59:16 */public class JSONTest &#123; public static void main(String[] args) &#123; Person person = new Person(); person.setId(1); person.setName(\"shi\"); person.setAge(22); person.setSex(\"male\"); // object to jsonstring String jString = JSON.toJSONString(person); System.out.println(jString); // jsonstring parse to map Map&lt;String,String&gt; map = (Map&lt;String, String&gt;)JSON.parse(jString); System.out.println(map.get(\"name\")); // jsonstring pare to object String str = \"&#123;\\\"age\\\":22,\\\"id\\\":1,\\\"name\\\":\\\"shi\\\",\\\"sex\\\":\\\"male\\\",\\\"dea\\\":\\\"male\\\",\\\"sasa\\\":\\\"male\\\"&#125;\"; Person p = JSON.parseObject(str, Person.class); System.out.println(p); /** * fastjson 转换key不区分大小写，转换没有明确的对应关系（多对多） */ &#125;&#125; 结论： fastjson 转换key不区分大小写，转换没有明确的对应关系（多对多）","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"},{"name":"json","slug":"json","permalink":"http://www.hansam.cc/tags/json/"}]},{"title":" 广告投放方式：CPC、CPM、CPA、CPS、CPT","date":"2017-07-09T10:17:23.000Z","path":"2017/07/09/广告投放方式：CPC、CPM、CPA、CPS、CPT/","text":"CPC（按点击付费） CPC—英文全称Cost PerClick。CPC是一种点击付费广告，根据广告被点击的次数收费。如关键词广告一般采用这种定价模式，比较典型的有Google的AdSensefor Content、百度联盟的百度竞价广告以及淘宝的直通车广告。 CPM（按展示付费） CPM—英文全称Cost Per Mille 或者是Cost PerThousandImpression。CPM是一种展示付费广告，只要展示了广告主的广告内容，广告主就为此付费。这种广告的效果不是很好，但是却能给有一定流量的网站、博客带来稳定的收入。 CPA（按行为付费） CPA—英文全称Cost PerAction。CPA是一种按广告投放实际效果计价方式的广告，即按回应的有效问卷或定单来计费，而不限广告投放量。CPA的计价方式对于网站而言有一定的风险，但若广告投放成功，其收益也比CPM的计价方式要大得多。 CPS（按销售付费） CPS—英文全称Cost PerSales。CPS是一种以实际销售产品数量来计算广告费用的广告，这种广告更多的适合购物类、导购类、网址导航类的网站，需要精准的流量才能带来转化。凡客的网站联盟是这种广告形式的典型代表。 CPT（按 时长付费） CPT—英文全称Cost PerTime。CPT是一种以时间来计费的广告，国内很多的网站都是按照“一个月多少钱”这种固定收费模式来收费的，这种广告形式很粗糙，无法保障客户的利益。但是CPT的确是一种很省心的广告，能给你的网站、博客带来稳定的收入。阿里妈妈的按周计费广告和门户网站的包月广告都属于这种CPT广告。相比而言，CPM和CPT对网站有利，而CPC、CPA、CPS则对广告主有利。目前比较流行的计价方式是CPM和CPC，最为流行的则为CPM。 其他相关内容：1、CPM 收费最科学的办法是按照有多少人看到你的广告来收费。按访问人次收费已经成为移动广告平台的惯例。CPM（千人成本）指的是广告投放过程中，听到或者看到某广告的每一人平均分担到多少广告成本。传统媒介多采用这种计价方式。在移动广告平台上，CPM取决于“印象”尺度，通常理解为一个人的眼睛在一段固定的时间内注视一个广告的次数。比如说一个内置广告横幅的单价是1元/CPM的话，意味着每一千个人次看到这个Ban-ner的话就收1元，如此类推，10，000人次访问的主页就是10元。至于每CPM的收费究竟是多少，要根据以手机应用的热门程度（即浏览人数）划分价格等级，采取固定费率。国际惯例是每CPM收费从5美元至200美元不等。2、CPC 以每点击一次计费。这样的方法加上点击率限制可以加强作弊的难度，而且是宣传的最优方式。但是，此类方法就有不少人觉得不公平，比如，虽然浏览者没有点击，但是他已经看到了广告，对于这些看到广告却没有点击的流量来说，广告成了白忙活。有很多手机应用不愿意做这样的广告，据说，是因为传统媒体从来都没有这样干过。3、CPA CPA计价方式是指按广告投放实际效果，即按回应的有效问卷或定单来计费，而不限广告投放量。CPA的计价方式对于网站而言有一定的风险，但若广告投放成功，其收益也比CPM的计价方式要大得多。据我所知7天酒店在投放网络广告的时候，有一部分就是这么干的，按照每注册一个会员，给网站付20元。说道收费方式CPM、CPC 、CPA三种收费方式只能比较出哪个更适合你而已。 无论采用CPM、CPC还是CPA，广告主都可以根据自身产品特性进行选择，这和传统互联网广告是一样的。由于电商行业的快速发展，目前移动广告平台还出现了CPS（按每次购买进行计费）的收费方式，但普遍效果还不够好，原因更多在于移动支付方面还有诸多不便的地方。 目前国内绝大部分移动广告平台都支持CPM、CPC、CPA计费，在选择移动广告投放时，广告主可更多考虑移动广告平台的稳定性和媒介资源深度。","tags":[{"name":"百科","slug":"百科","permalink":"http://www.hansam.cc/tags/百科/"}]},{"title":"SpringMVC项目JSP取不到ModelAndView的数据解决","date":"2017-07-09T10:11:36.000Z","path":"2017/07/09/SpringMVC项目JSP取不到ModelAndView的数据解决/","text":"使用maven构建的springmvc项目EL表达式取不到值,不管是用 ${msg}还是用JSTL的 都不行我是用maven自动生成的web.xml文件 如下： &lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt; &lt;web-app&gt; &lt;/web-app&gt; 但这样的文件不行，需要改成 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app&gt; &lt;/web-app&gt; 重启就OK了，现在上面的两种方法都支持了。","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"}]},{"title":"Java资源绑定（ResourceBundle）示例","date":"2017-07-04T15:42:00.000Z","path":"2017/07/04/Java资源绑定（ResourceBundle）示例/","text":"java.util.ResourceBundle 是用于国际化（多语言）的库。它能够根据为系统配置的默认区域设置返回消息。当开发适用于世界各地使用的系统时，就可以使用这样的功能。 1.它是如何工作的？ 库是基于在属性命名中使用的区域设置和名称后缀读取属性文件。例如，考虑一个名为MyLabels_en_US.properties的标签文件。当Locale设置表示US-English的en_US时，此文件由ResourceBundle程序读取。区域设置表示具有其属性的区域或位置。Locale通常用于使用我们的应用程序维护有关客户端的详细信息。 区域设置包含要用于相应位置的位置和语言的属性。 因此，Locale通过确定用户所属的位置来帮助ResourceBundle选择正确的标签文件。 2.示例让我们看看下面的例子，以更清楚地说明这个问题： MyLabels_en_US.properties 文件有以下内容 - how_are_you = How are you? Java MyLabels_ms_MY.properties 文件有以下内容 - how_are_you = apa khabar Java 完整的程序代码如下 - import java.util.Locale; import java.util.ResourceBundle; public class Application { public static void main(String[] args) { // en_US System.out.println(&quot;Current Locale: &quot; + Locale.getDefault()); ResourceBundle mybundle = ResourceBundle.getBundle(&quot;MyLabels&quot;); // read MyLabels_en_US.properties System.out.println(&quot;Say how are you in US English: &quot; + mybundle.getString(&quot;how_are_you&quot;)); Locale.setDefault(new Locale(&quot;ms&quot; &quot;MY&quot;)); // read MyLabels_ms_MY.properties System.out.println(&quot;Current Locale: &quot; + Locale.getDefault()); mybundle = ResourceBundle.getBundle(&quot;MyLabels&quot;); System.out.println(&quot;Say how are you in Malaysian Malaya language: &quot; + mybundle.getString(&quot;how_are_you&quot;)); } } Java在执行此代码时，得到以下输出： Current Locale: en_US Say how are you in US English: How are you? Current Locale: ms_MY Say how are you in Malaysian Malaya language: apa khabar Java 在输出中可以看到，取决于为Locale集设置的默认值。此实用程序主要用于Web应用程序，其中Web浏览器有助于了解远程用户的区域设置。这使得尽可能以特定语言显示网站成为可能。","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"}]},{"title":"Java中堆内存和栈内存详解","date":"2017-07-04T15:27:43.000Z","path":"2017/07/04/Java中堆内存和栈内存详解/","text":"数据结构的栈和堆 首先在数据结构上要知道堆栈，尽管我们这么称呼它，但实际上堆栈是两种数据结构：堆和栈。 堆和栈都是一种数据项按序排列的数据结构 栈就像装数据的桶或箱子 我们先从大家比较熟悉的栈说起吧，它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我们首先要移开压在它上面的物体（放入的比较晚的物体）。 堆像一棵倒过来的树 而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。 Java中内存分配策略及堆和栈的比较1 内存分配策略 按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的. 静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求. 栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。 静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放. 2 堆和栈的比较 上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈: 从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的: 在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时. 堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~). 3 JVM中的堆和栈 JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的. 从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。 每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。 Java 中的堆和栈 Java把内存划分成两种：一种是栈内存，一种是堆内存。 在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 具体的说： 栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int,short, long, byte, float, double, boolean, char)和对象句柄。 栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： int a = 3; int b = 3; 编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"}]},{"title":"my-first-blog","date":"2017-05-02T01:13:21.000Z","path":"2017/05/02/my-first-blog/","text":"这是我的第一篇博客 我此时正在图书馆，准备毕业答辩的相关事宜。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.hansam.cc/tags/随笔/"}]}]