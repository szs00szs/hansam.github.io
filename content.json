[{"title":"java特殊注释","date":"2017-07-18T15:01:13.000Z","path":"2017/07/18/java特殊注释/","text":"java中的特殊注释： 1. TODO 表示需要实现，但目前还未实现的功能 2. XXX 勉强可以工作，但是性能差等原因 3. FIXME 代码是错误的，不能工作，需要修复 TODO: + 说明： 如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。 FIXME: + 说明： 如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。 XXX: + 说明： 如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。 eclipse中特殊的注释： 在eclipse中，TODO、FIXME和XXX都会被eclipse的task视图所收集。在项目发布前，检查一下task视图是一个很好的习惯。此外，在eclipse中，我们可自定义自己的特殊注释标签。如在Java中，进入123A[Windows] --&gt; B[Java] B --&gt; C[Compiler]C --&gt; D[Task Tags] 窗口即可添加特殊标签，默认只有TODO、FIXME和XXX。","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"},{"name":"笔记","slug":"笔记","permalink":"http://www.hansam.cc/tags/笔记/"}]},{"title":"fastjson基础测试","date":"2017-07-17T14:57:53.000Z","path":"2017/07/17/fastjson基础测试/","text":"fastjson使用测试 12345678910111213141516171819202122232425262728293031323334353637383940package cc.hansam.mystudy.json;import java.util.Map;import com.alibaba.fastjson.JSON;/** * @author hansam 945210972@qq.com * @date 2017年7月17日下午4:59:16 */public class JSONTest &#123; public static void main(String[] args) &#123; Person person = new Person(); person.setId(1); person.setName(\"shi\"); person.setAge(22); person.setSex(\"male\"); // object to jsonstring String jString = JSON.toJSONString(person); System.out.println(jString); // jsonstring parse to map Map&lt;String,String&gt; map = (Map&lt;String, String&gt;)JSON.parse(jString); System.out.println(map.get(\"name\")); // jsonstring pare to object String str = \"&#123;\\\"age\\\":22,\\\"id\\\":1,\\\"name\\\":\\\"shi\\\",\\\"sex\\\":\\\"male\\\",\\\"dea\\\":\\\"male\\\",\\\"sasa\\\":\\\"male\\\"&#125;\"; Person p = JSON.parseObject(str, Person.class); System.out.println(p); /** * fastjson 转换key不区分大小写，转换没有明确的对应关系（多对多） */ &#125;&#125; 结论： fastjson 转换key不区分大小写，转换没有明确的对应关系（多对多）","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"},{"name":"json","slug":"json","permalink":"http://www.hansam.cc/tags/json/"}]},{"title":" 广告投放方式：CPC、CPM、CPA、CPS、CPT","date":"2017-07-09T10:17:23.000Z","path":"2017/07/09/广告投放方式：CPC、CPM、CPA、CPS、CPT/","text":"CPC（按点击付费） CPC—英文全称Cost PerClick。CPC是一种点击付费广告，根据广告被点击的次数收费。如关键词广告一般采用这种定价模式，比较典型的有Google的AdSensefor Content、百度联盟的百度竞价广告以及淘宝的直通车广告。 CPM（按展示付费） CPM—英文全称Cost Per Mille 或者是Cost PerThousandImpression。CPM是一种展示付费广告，只要展示了广告主的广告内容，广告主就为此付费。这种广告的效果不是很好，但是却能给有一定流量的网站、博客带来稳定的收入。 CPA（按行为付费） CPA—英文全称Cost PerAction。CPA是一种按广告投放实际效果计价方式的广告，即按回应的有效问卷或定单来计费，而不限广告投放量。CPA的计价方式对于网站而言有一定的风险，但若广告投放成功，其收益也比CPM的计价方式要大得多。 CPS（按销售付费） CPS—英文全称Cost PerSales。CPS是一种以实际销售产品数量来计算广告费用的广告，这种广告更多的适合购物类、导购类、网址导航类的网站，需要精准的流量才能带来转化。凡客的网站联盟是这种广告形式的典型代表。 CPT（按 时长付费） CPT—英文全称Cost PerTime。CPT是一种以时间来计费的广告，国内很多的网站都是按照“一个月多少钱”这种固定收费模式来收费的，这种广告形式很粗糙，无法保障客户的利益。但是CPT的确是一种很省心的广告，能给你的网站、博客带来稳定的收入。阿里妈妈的按周计费广告和门户网站的包月广告都属于这种CPT广告。相比而言，CPM和CPT对网站有利，而CPC、CPA、CPS则对广告主有利。目前比较流行的计价方式是CPM和CPC，最为流行的则为CPM。 其他相关内容：1、CPM 收费最科学的办法是按照有多少人看到你的广告来收费。按访问人次收费已经成为移动广告平台的惯例。CPM（千人成本）指的是广告投放过程中，听到或者看到某广告的每一人平均分担到多少广告成本。传统媒介多采用这种计价方式。在移动广告平台上，CPM取决于“印象”尺度，通常理解为一个人的眼睛在一段固定的时间内注视一个广告的次数。比如说一个内置广告横幅的单价是1元/CPM的话，意味着每一千个人次看到这个Ban-ner的话就收1元，如此类推，10，000人次访问的主页就是10元。至于每CPM的收费究竟是多少，要根据以手机应用的热门程度（即浏览人数）划分价格等级，采取固定费率。国际惯例是每CPM收费从5美元至200美元不等。2、CPC 以每点击一次计费。这样的方法加上点击率限制可以加强作弊的难度，而且是宣传的最优方式。但是，此类方法就有不少人觉得不公平，比如，虽然浏览者没有点击，但是他已经看到了广告，对于这些看到广告却没有点击的流量来说，广告成了白忙活。有很多手机应用不愿意做这样的广告，据说，是因为传统媒体从来都没有这样干过。3、CPA CPA计价方式是指按广告投放实际效果，即按回应的有效问卷或定单来计费，而不限广告投放量。CPA的计价方式对于网站而言有一定的风险，但若广告投放成功，其收益也比CPM的计价方式要大得多。据我所知7天酒店在投放网络广告的时候，有一部分就是这么干的，按照每注册一个会员，给网站付20元。说道收费方式CPM、CPC 、CPA三种收费方式只能比较出哪个更适合你而已。 无论采用CPM、CPC还是CPA，广告主都可以根据自身产品特性进行选择，这和传统互联网广告是一样的。由于电商行业的快速发展，目前移动广告平台还出现了CPS（按每次购买进行计费）的收费方式，但普遍效果还不够好，原因更多在于移动支付方面还有诸多不便的地方。 目前国内绝大部分移动广告平台都支持CPM、CPC、CPA计费，在选择移动广告投放时，广告主可更多考虑移动广告平台的稳定性和媒介资源深度。","tags":[{"name":"百科","slug":"百科","permalink":"http://www.hansam.cc/tags/百科/"}]},{"title":"SpringMVC项目JSP取不到ModelAndView的数据解决","date":"2017-07-09T10:11:36.000Z","path":"2017/07/09/SpringMVC项目JSP取不到ModelAndView的数据解决/","text":"使用maven构建的springmvc项目EL表达式取不到值,不管是用 ${msg}还是用JSTL的 都不行我是用maven自动生成的web.xml文件 如下： &lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt; &lt;web-app&gt; &lt;/web-app&gt; 但这样的文件不行，需要改成 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app&gt; &lt;/web-app&gt; 重启就OK了，现在上面的两种方法都支持了。","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"}]},{"title":"Java资源绑定（ResourceBundle）示例","date":"2017-07-04T15:42:00.000Z","path":"2017/07/04/Java资源绑定（ResourceBundle）示例/","text":"java.util.ResourceBundle 是用于国际化（多语言）的库。它能够根据为系统配置的默认区域设置返回消息。当开发适用于世界各地使用的系统时，就可以使用这样的功能。 1.它是如何工作的？ 库是基于在属性命名中使用的区域设置和名称后缀读取属性文件。例如，考虑一个名为MyLabels_en_US.properties的标签文件。当Locale设置表示US-English的en_US时，此文件由ResourceBundle程序读取。区域设置表示具有其属性的区域或位置。Locale通常用于使用我们的应用程序维护有关客户端的详细信息。 区域设置包含要用于相应位置的位置和语言的属性。 因此，Locale通过确定用户所属的位置来帮助ResourceBundle选择正确的标签文件。 2.示例让我们看看下面的例子，以更清楚地说明这个问题： MyLabels_en_US.properties 文件有以下内容 - how_are_you = How are you? Java MyLabels_ms_MY.properties 文件有以下内容 - how_are_you = apa khabar Java 完整的程序代码如下 - import java.util.Locale; import java.util.ResourceBundle; public class Application { public static void main(String[] args) { // en_US System.out.println(&quot;Current Locale: &quot; + Locale.getDefault()); ResourceBundle mybundle = ResourceBundle.getBundle(&quot;MyLabels&quot;); // read MyLabels_en_US.properties System.out.println(&quot;Say how are you in US English: &quot; + mybundle.getString(&quot;how_are_you&quot;)); Locale.setDefault(new Locale(&quot;ms&quot; &quot;MY&quot;)); // read MyLabels_ms_MY.properties System.out.println(&quot;Current Locale: &quot; + Locale.getDefault()); mybundle = ResourceBundle.getBundle(&quot;MyLabels&quot;); System.out.println(&quot;Say how are you in Malaysian Malaya language: &quot; + mybundle.getString(&quot;how_are_you&quot;)); } } Java在执行此代码时，得到以下输出： Current Locale: en_US Say how are you in US English: How are you? Current Locale: ms_MY Say how are you in Malaysian Malaya language: apa khabar Java 在输出中可以看到，取决于为Locale集设置的默认值。此实用程序主要用于Web应用程序，其中Web浏览器有助于了解远程用户的区域设置。这使得尽可能以特定语言显示网站成为可能。","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"}]},{"title":"Java中堆内存和栈内存详解","date":"2017-07-04T15:27:43.000Z","path":"2017/07/04/Java中堆内存和栈内存详解/","text":"数据结构的栈和堆 首先在数据结构上要知道堆栈，尽管我们这么称呼它，但实际上堆栈是两种数据结构：堆和栈。 堆和栈都是一种数据项按序排列的数据结构 栈就像装数据的桶或箱子 我们先从大家比较熟悉的栈说起吧，它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我们首先要移开压在它上面的物体（放入的比较晚的物体）。 堆像一棵倒过来的树 而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。 Java中内存分配策略及堆和栈的比较1 内存分配策略 按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的. 静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求. 栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。 静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放. 2 堆和栈的比较 上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈: 从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的: 在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时. 堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~). 3 JVM中的堆和栈 JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的. 从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。 每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。 Java 中的堆和栈 Java把内存划分成两种：一种是栈内存，一种是堆内存。 在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 具体的说： 栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int,short, long, byte, float, double, boolean, char)和对象句柄。 栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： int a = 3; int b = 3; 编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。","tags":[{"name":"java","slug":"java","permalink":"http://www.hansam.cc/tags/java/"}]},{"title":"my-first-blog","date":"2017-05-02T01:13:21.000Z","path":"2017/05/02/my-first-blog/","text":"这是我的第一篇博客 我此时正在图书馆，准备毕业答辩的相关事宜。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.hansam.cc/tags/随笔/"}]}]