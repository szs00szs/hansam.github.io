<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hansam Blogs</title>
  <subtitle>you got a dream,you got to protect it :)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.hansam.cc/"/>
  <updated>2017-07-22T16:07:45.768Z</updated>
  <id>http://www.hansam.cc/</id>
  
  <author>
    <name>Hansam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Socket编程</title>
    <link href="http://www.hansam.cc/2017/07/22/Java-Sockett%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.hansam.cc/2017/07/22/Java-Sockett编程/</id>
    <published>2017-07-22T15:34:51.000Z</published>
    <updated>2017-07-22T16:07:45.768Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java</strong>最初是作为网络编程语言出现的，其对网络提供了高度的支持，而在网络编程中，使用最多的就是Socket。QQ、MSN都使用了Socket相关的技术。</p>
<hr>
<h3 id="一、计算机网络基础"><a href="#一、计算机网络基础" class="headerlink" title="一、计算机网络基础"></a>一、计算机网络基础</h3><h4 id="1-两台计算机间进行通讯需要以下三个条件："><a href="#1-两台计算机间进行通讯需要以下三个条件：" class="headerlink" title="1. 两台计算机间进行通讯需要以下三个条件："></a>1. 两台计算机间进行通讯需要以下三个条件：</h4><blockquote>
<p>ip地址、协议、端口号</p>
<h4 id="2-TCP-IP协议"><a href="#2-TCP-IP协议" class="headerlink" title="2. TCP/IP协议"></a>2. TCP/IP协议</h4><p>是以TCP和IP为基础的不同层次上多个协议的集合，也称TCP/IP协议族、或TCP/IP协议栈<br>TCP：Transmission Control Protocol 传输控制协议<br>IP：Internet Protocol 互联网协议</p>
<h4 id="3-TCP-IP五层模型"><a href="#3-TCP-IP五层模型" class="headerlink" title="3. TCP/IP五层模型"></a>3. TCP/IP五层模型</h4><p>应用层<br>运输层<br>网络层<br>数据链路层<br>物理层</p>
<h4 id="4-IP地址"><a href="#4-IP地址" class="headerlink" title="4. IP地址"></a>4. IP地址</h4><p>为实现网络中不同计算机之间的通信，每台计算机都必须有一个唯一的标识(32bit)。</p>
<h4 id="5-端口"><a href="#5-端口" class="headerlink" title="5. 端口"></a>5. 端口</h4><p>区分一台主机的多个不同应用程序，端口号范围为0-65535，其中0-1023位为系统保留。<br>如：HTTP：80FTP：21 Telnet：23<br>IP地址+端口号组成了所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点，是TCP和UDP的基础</p>
<h4 id="6-Socket套接字"><a href="#6-Socket套接字" class="headerlink" title="6. Socket套接字"></a>6. Socket套接字</h4><p>IP地址+端口,组合在一起才能构成唯一能识别的标识符套接字<br>Socket原理机制：<br>通信的两端都有Socket<br>网络通信其实就是Socket间的通信<br>数据在两个Socket间通过IO传输    </p>
<h4 id="7-Java中的网络支持"><a href="#7-Java中的网络支持" class="headerlink" title="7. Java中的网络支持"></a>7. Java中的网络支持</h4><p>针对网络通信的不同层次，Java提供了不同的API，其提供的网络功能有四大类：<br>InetAddress:用于标识网络上的硬件资源，主要是IP地址<br>URL：统一资源定位符，通过URL可以直接读取或写入网络上的数据<br>Sockets：使用TCP协议实现的网络通信Socket相关的类<br>Datagram:使用UDP协议，将数据保存在用户数据报中，通过网络进行通信。</p>
</blockquote>
<h3 id="二、InetAddress"><a href="#二、InetAddress" class="headerlink" title="二、InetAddress"></a>二、InetAddress</h3><blockquote>
<p>InetAddress类用于标识网络上的硬件资源，标识IP地址。<br>该类没有构造方法<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取本机的InetAddress实例 </span></div><div class="line">InetAddress address =InetAddress.getLocalHost(); </div><div class="line">address.getHostName();<span class="comment">//获取计算机名 </span></div><div class="line">address.getHostAddress();<span class="comment">//获取IP地址 </span></div><div class="line">byte[] <span class="built_in">bytes</span> = address.getAddress();<span class="comment">//获取字节数组形式的IP地址,以点分隔的四部分 </span></div><div class="line"> </div><div class="line"><span class="comment">//获取其他主机的InetAddress实例 </span></div><div class="line">InetAddress address2 =InetAddress.getByName(<span class="string">"其他主机名"</span>); </div><div class="line">InetAddress address3 =InetAddress.getByName(<span class="string">"IP地址"</span>);</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="三、URL类"><a href="#三、URL类" class="headerlink" title="三、URL类"></a>三、URL类</h3><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个URL的实例 </span></div><div class="line">URL baidu =<span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>); </div><div class="line">URL <span class="built_in">url</span> =<span class="keyword">new</span> URL(baidu,<span class="string">"/index.html?username=tom#test"</span>);<span class="comment">//？表示参数，#表示锚点 </span></div><div class="line"><span class="built_in">url</span>.getProtocol();<span class="comment">//获取协议 </span></div><div class="line"><span class="built_in">url</span>.getHost();<span class="comment">//获取主机 </span></div><div class="line"><span class="built_in">url</span>.getPort();<span class="comment">//如果没有指定端口号，根据协议不同使用默认端口。此时getPort()方法的返回值为 -1 </span></div><div class="line"><span class="built_in">url</span>.getPath();<span class="comment">//获取文件路径 </span></div><div class="line"><span class="built_in">url</span>.getFile();<span class="comment">//文件名，包括文件路径+参数 </span></div><div class="line"><span class="built_in">url</span>.getRef();<span class="comment">//相对路径，就是锚点，即#号后面的内容 </span></div><div class="line"><span class="built_in">url</span>.getQuery();<span class="comment">//查询字符串，即参数</span></div></pre></td></tr></table></figure>
<h4 id="使用URL读取网页内容"><a href="#使用URL读取网页内容" class="headerlink" title="使用URL读取网页内容"></a>使用URL读取网页内容</h4><blockquote>
<p>通过URL对象的openStream()方法可以得到指定资源的输入流，通过流能够读取或访问网页上的资源<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用URL读取网页内容 </span></div><div class="line"><span class="comment">//创建一个URL实例 </span></div><div class="line">URL url =new URL(<span class="string">"http://www.baidu.com"</span>); </div><div class="line">InputStream <span class="keyword">is</span> = url.openStream();<span class="comment">//通过openStream方法获取资源的字节输入流 </span></div><div class="line">InputStreamReader isr =newInputStreamReader(<span class="keyword">is</span>,<span class="string">"UTF-8"</span>);<span class="comment">//将字节输入流转换为字符输入流,如果不指定编码，中文可能会出现乱码 </span></div><div class="line">BufferedReader br =newBufferedReader(isr);<span class="comment">//为字符输入流添加缓冲，提高读取效率 </span></div><div class="line">String <span class="keyword">data</span> = br.readLine();<span class="comment">//读取数据 </span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">data</span>!=<span class="literal">null</span>)&#123; </div><div class="line">System.<span class="keyword">out</span>.println(<span class="keyword">data</span>);<span class="comment">//输出数据 </span></div><div class="line"><span class="keyword">data</span> = br.readerLine(); </div><div class="line">&#125; </div><div class="line">br.close(); </div><div class="line">isr.colose(); </div><div class="line"><span class="keyword">is</span>.close();</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="四、TCP编程"><a href="#四、TCP编程" class="headerlink" title="四、TCP编程"></a>四、TCP编程</h3><h4 id="1-TCP协议"><a href="#1-TCP协议" class="headerlink" title="1. TCP协议"></a>1. TCP协议</h4><blockquote>
<p>是面向连接的、可靠的、有序的、以字节流的方式发送数据，通过三次握手方式建立连接，形成传输数据的通道，在连接中进行大量数据的传输，效率会稍低。</p>
</blockquote>
<h4 id="2-Java中基于TCP协议实现网络通信的类"><a href="#2-Java中基于TCP协议实现网络通信的类" class="headerlink" title="2. Java中基于TCP协议实现网络通信的类"></a>2. Java中基于TCP协议实现网络通信的类</h4><blockquote>
<p>客户端的Socket类<br>服务器端的ServerSocket类<br><img src="http://s9.51cto.com/wyfs02/M01/72/D1/wKioL1XuRtDx8IG2AACLNnarS5A899.jpg-wh_651x-s_3157864048.jpg" alt="socket通信模型"></p>
<h4 id="3-Socket通信的步骤"><a href="#3-Socket通信的步骤" class="headerlink" title="3. Socket通信的步骤"></a>3. Socket通信的步骤</h4><p>① 创建ServerSocket和Socket<br>② 打开连接到Socket的输入/输出流<br>③ 按照协议对Socket进行读/写操作<br>④ 关闭输入输出流、关闭Socket</p>
<h4 id="4-服务器端"><a href="#4-服务器端" class="headerlink" title="4. 服务器端"></a>4. 服务器端</h4><p>① 创建ServerSocket对象，绑定监听端口<br>② 通过accept()方法监听客户端请求<br>③ 连接建立后，通过输入流读取客户端发送的请求信息<br>④ 通过输出流向客户端发送乡音信息<br>⑤ 关闭相关资源<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> 基于TCP协议的Socket通信，实现用户登录，服务端 </div><div class="line">*/ </div><div class="line"><span class="comment">//1、创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并监听此端口 </span></div><div class="line">ServerSocket serverSocket =newServerSocket(<span class="number">10086</span>);<span class="comment">//1024-65535的某个端口 </span></div><div class="line"><span class="comment">//2、调用accept()方法开始监听，等待客户端的连接 </span></div><div class="line">Socket socket = serverSocket.accept(); </div><div class="line"><span class="comment">//3、获取输入流，并读取客户端信息 </span></div><div class="line">InputStream is = socket.getInputStream(); </div><div class="line">InputStreamReader isr =newInputStreamReader(is); </div><div class="line">BufferedReader br =newBufferedReader(isr); </div><div class="line"><span class="keyword">String</span> info =null; </div><div class="line"><span class="built_in">while</span>((info=br.readLine())!=null)&#123; </div><div class="line">System.out.<span class="built_in">println</span>(<span class="string">"我是服务器，客户端说："</span>+info)； </div><div class="line">&#125; </div><div class="line">socket.shutdownInput();<span class="comment">//关闭输入流 </span></div><div class="line"><span class="comment">//4、获取输出流，响应客户端的请求 </span></div><div class="line">OutputStream os = socket.getOutputStream(); </div><div class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(os); </div><div class="line">pw.<span class="built_in">write</span>(<span class="string">"欢迎您！"</span>); </div><div class="line">pw.<span class="built_in">flush</span>(); </div><div class="line"> </div><div class="line"><span class="comment">//5、关闭资源 </span></div><div class="line">pw.<span class="built_in">close</span>(); </div><div class="line">os.<span class="built_in">close</span>(); </div><div class="line">br.<span class="built_in">close</span>(); </div><div class="line">isr.<span class="built_in">close</span>(); </div><div class="line">is.<span class="built_in">close</span>(); </div><div class="line">socket.<span class="built_in">close</span>(); </div><div class="line">serverSocket.<span class="built_in">close</span>();</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="5-客户端"><a href="#5-客户端" class="headerlink" title="5. 客户端"></a>5. 客户端</h4><blockquote>
<p>① 创建Socket对象，指明需要连接的服务器的地址和端口号<br>② 连接建立后，通过输出流想服务器端发送请求信息<br>③ 通过输入流获取服务器响应的信息<br>④ 关闭响应资源<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//客户端 </span></div><div class="line"><span class="comment">//1、创建客户端Socket，指定服务器地址和端口 </span></div><div class="line">Socket socket =newSocket(<span class="string">"localhost"</span>,<span class="number">10086</span>); </div><div class="line"><span class="comment">//2、获取输出流，向服务器端发送信息 </span></div><div class="line">OutputStream os = socket.getOutputStream();<span class="comment">//字节输出流 </span></div><div class="line">PrintWriter pw =newPrintWriter(os);<span class="comment">//将输出流包装成打印流 </span></div><div class="line">pw.<span class="built_in">write</span>(<span class="string">"用户名：admin；密码：123"</span>); </div><div class="line">pw.<span class="built_in">flush</span>(); </div><div class="line">socket.shutdownOutput(); </div><div class="line"><span class="comment">//3、获取输入流，并读取服务器端的响应信息 </span></div><div class="line">InputStream is = socket.getInputStream(); </div><div class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is)); </div><div class="line"><span class="keyword">String</span> info = null; </div><div class="line"><span class="built_in">while</span>((info=br.readLine())!null)&#123; </div><div class="line"> System.out.<span class="built_in">println</span>(<span class="string">"我是客户端，服务器说："</span>+info); </div><div class="line">&#125; </div><div class="line"> </div><div class="line"><span class="comment">//4、关闭资源 </span></div><div class="line">br.<span class="built_in">close</span>(); </div><div class="line">is.<span class="built_in">close</span>(); </div><div class="line">pw.<span class="built_in">close</span>(); </div><div class="line">os.<span class="built_in">close</span>(); </div><div class="line">socket.<span class="built_in">close</span>();</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="6-应用多线程实现服务器与多客户端之间的通信"><a href="#6-应用多线程实现服务器与多客户端之间的通信" class="headerlink" title="6. 应用多线程实现服务器与多客户端之间的通信"></a>6. 应用多线程实现服务器与多客户端之间的通信</h4><blockquote>
<p>① 服务器端创建ServerSocket，循环调用accept()等待客户端连接<br>② 客户端创建一个socket并请求和服务器端连接<br>③ 服务器端接受苦读段请求，创建socket与该客户建立专线连接<br>④ 建立连接的两个socket在一个单独的线程上对话<br>⑤ 服务器端继续等待新的连接<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//服务器线程处理 </span></div><div class="line"><span class="comment">//和本线程相关的socket </span></div><div class="line">Socket socket =<span class="keyword">null</span>; </div><div class="line"><span class="comment">// </span></div><div class="line"><span class="keyword">public</span> serverThread(Socket socket)&#123; </div><div class="line"><span class="keyword">this</span>.socket = socket; </div><div class="line">&#125; </div><div class="line"> </div><div class="line">publicvoid run()&#123; </div><div class="line"><span class="comment">//服务器处理代码 </span></div><div class="line">&#125; </div><div class="line"> </div><div class="line"><span class="comment">//============================================ </span></div><div class="line"><span class="comment">//服务器代码 </span></div><div class="line">ServerSocket serverSocket =newServerSocket(<span class="number">10086</span>); </div><div class="line">Socket socket =<span class="keyword">null</span>; </div><div class="line"><span class="keyword">int</span> <span class="keyword">count</span> =<span class="number">0</span>;<span class="comment">//记录客户端的数量 </span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; </div><div class="line">socket = serverScoket.accept(); </div><div class="line">ServerThread serverThread =newServerThread(socket); </div><div class="line"> serverThread.start(); </div><div class="line"> <span class="keyword">count</span>++; </div><div class="line">System.out.<span class="keyword">println</span>(<span class="string">"客户端连接的数量："</span>+<span class="keyword">count</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="五、UDP编程"><a href="#五、UDP编程" class="headerlink" title="五、UDP编程"></a>五、UDP编程</h3><blockquote>
<p>UDP协议（用户数据报协议）是无连接的、不可靠的、无序的,速度快<br>进行数据传输时，首先将要传输的数据定义成数据报（Datagram），大小限制在64k，在数据报中指明数据所要达到的Socket（主机地址和端口号），然后再将数据报发送出去。<br>DatagramPacket类:表示数据报包<br>DatagramSocket类：进行端到端通信的类</p>
</blockquote>
<h4 id="1-服务器端实现步骤"><a href="#1-服务器端实现步骤" class="headerlink" title="1. 服务器端实现步骤"></a>1. 服务器端实现步骤</h4><blockquote>
<p>① 创建DatagramSocket，指定端口号<br>② 创建DatagramPacket<br>③ 接受客户端发送的数据信息<br>④ 读取数据<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//服务器端，实现基于UDP的用户登录 </span></div><div class="line"><span class="comment">//1、创建服务器端DatagramSocket，指定端口 </span></div><div class="line">DatagramSocket socket =<span class="keyword">new</span> <span class="type">datagramSocket</span>(<span class="number">10010</span>); </div><div class="line"><span class="comment">//2、创建数据报，用于接受客户端发送的数据 </span></div><div class="line">byte[] data =<span class="keyword">new</span><span class="type">byte</span>[<span class="number">1024</span>];<span class="comment">// </span></div><div class="line">DatagramPacket packet =<span class="keyword">new</span><span class="type">DatagramPacket</span>(data,data.length); </div><div class="line"><span class="comment">//3、接受客户端发送的数据 </span></div><div class="line">socket.receive(packet);<span class="comment">//此方法在接受数据报之前会一致阻塞 </span></div><div class="line"><span class="comment">//4、读取数据 </span></div><div class="line"><span class="keyword">String</span> info =<span class="keyword">new</span><span class="type">String</span>(data,o,data.length); </div><div class="line">System.out.println(<span class="string">"我是服务器，客户端告诉我"</span>+info); </div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//========================================================= </span></div><div class="line"><span class="comment">//向客户端响应数据 </span></div><div class="line"><span class="comment">//1、定义客户端的地址、端口号、数据 </span></div><div class="line">InetAddress address = packet.getAddress(); </div><div class="line">int port = packet.getPort(); </div><div class="line">byte[] data2 = <span class="string">"欢迎您！"</span>.geyBytes(); </div><div class="line"><span class="comment">//2、创建数据报，包含响应的数据信息 </span></div><div class="line">DatagramPacket packet2 = <span class="keyword">new</span> <span class="type">DatagramPacket</span>(data2,data2.length,address,port); </div><div class="line"><span class="comment">//3、响应客户端 </span></div><div class="line">socket.send(packet2); </div><div class="line"><span class="comment">//4、关闭资源 </span></div><div class="line">socket.close();</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2-客户端实现步骤"><a href="#2-客户端实现步骤" class="headerlink" title="2. 客户端实现步骤"></a>2. 客户端实现步骤</h4><blockquote>
<p>① 定义发送信息<br>② 创建DatagramPacket，包含将要发送的信息<br>③ 创建DatagramSocket<br>④ 发送数据<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//客户端 </span></div><div class="line"><span class="comment">//1、定义服务器的地址、端口号、数据 </span></div><div class="line">InetAddress address =InetAddress.getByName(<span class="string">"localhost"</span>); </div><div class="line"><span class="keyword">int</span> port =<span class="number">10010</span>; </div><div class="line"><span class="keyword">byte</span>[] data =<span class="string">"用户名：admin;密码：123"</span>.getBytes(); </div><div class="line"><span class="comment">//2、创建数据报，包含发送的数据信息 </span></div><div class="line">DatagramPacket packet = newDatagramPacket(data,data,length,address,port); </div><div class="line"><span class="comment">//3、创建DatagramSocket对象 </span></div><div class="line">DatagramSocket socket =newDatagramSocket(); </div><div class="line"><span class="comment">//4、向服务器发送数据 </span></div><div class="line">socket.send(packet); </div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//接受服务器端响应数据 </span></div><div class="line"><span class="comment">//====================================== </span></div><div class="line"><span class="comment">//1、创建数据报，用于接受服务器端响应数据 </span></div><div class="line"><span class="keyword">byte</span>[] data2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; </div><div class="line">DatagramPacket packet2 = <span class="keyword">new</span> DatagramPacket(data2,data2.length); </div><div class="line"><span class="comment">//2、接受服务器响应的数据 </span></div><div class="line">socket.receive(packet2); </div><div class="line"><span class="keyword">String</span> raply = <span class="keyword">new</span> <span class="keyword">String</span>(data2,<span class="number">0</span>,packet2.getLenth()); </div><div class="line">System.out.<span class="built_in">println</span>(<span class="string">"我是客户端，服务器说："</span>+reply); </div><div class="line"><span class="comment">//4、关闭资源 </span></div><div class="line">socket.<span class="built_in">close</span>();</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="六、注意问题"><a href="#六、注意问题" class="headerlink" title="六、注意问题"></a>六、注意问题</h3><h4 id="1-多线程的优先级问题："><a href="#1-多线程的优先级问题：" class="headerlink" title="1. 多线程的优先级问题："></a>1. 多线程的优先级问题：</h4><blockquote>
<p>根据实际的经验，适当的降低优先级，否侧可能会有程序运行效率低的情况</p>
<h4 id="2-是否关闭输出流和输入流："><a href="#2-是否关闭输出流和输入流：" class="headerlink" title="2. 是否关闭输出流和输入流："></a>2. 是否关闭输出流和输入流：</h4><p>对于同一个socket，如果关闭了输出流，则与该输出流关联的socket也会被关闭，所以一般不用关闭流，直接关闭socket即可</p>
<h4 id="3-使用TCP通信传输对象，IO中序列化部分"><a href="#3-使用TCP通信传输对象，IO中序列化部分" class="headerlink" title="3. 使用TCP通信传输对象，IO中序列化部分"></a>3. 使用TCP通信传输对象，IO中序列化部分</h4><h4 id="4-Socket编程传递文件，IO流部分"><a href="#4-Socket编程传递文件，IO流部分" class="headerlink" title="4. Socket编程传递文件，IO流部分"></a>4. Socket编程传递文件，IO流部分</h4></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt;最初是作为网络编程语言出现的，其对网络提供了高度的支持，而在网络编程中，使用最多的就是Socket。QQ、MSN都使用了Socket相关的技术。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、计算机网络基础&quot;&gt;&lt;a href=&quot;#一、计算机
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java特殊注释</title>
    <link href="http://www.hansam.cc/2017/07/18/java%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A/"/>
    <id>http://www.hansam.cc/2017/07/18/java特殊注释/</id>
    <published>2017-07-18T15:01:13.000Z</published>
    <updated>2017-07-18T15:27:05.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java中的特殊注释："><a href="#java中的特殊注释：" class="headerlink" title="java中的特殊注释："></a>java中的特殊注释：</h2><hr>
<h3 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h3><blockquote>
<p>表示需要实现，但目前还未实现的功能</p>
</blockquote>
<h3 id="2-XXX"><a href="#2-XXX" class="headerlink" title="2. XXX"></a>2. XXX</h3><blockquote>
<p>勉强可以工作，但是性能差等原因</p>
</blockquote>
<h3 id="3-FIXME"><a href="#3-FIXME" class="headerlink" title="3. FIXME"></a>3. FIXME</h3><blockquote>
<p>代码是错误的，不能工作，需要修复</p>
</blockquote>
<hr>
<p><strong>TODO: + 说明：</strong></p>
<blockquote>
<p>如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</p>
</blockquote>
<p><strong>FIXME: + 说明：</strong></p>
<blockquote>
<p>如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p>
</blockquote>
<p><strong>XXX: + 说明：</strong></p>
<blockquote>
<p>如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</p>
</blockquote>
<p><strong>eclipse中特殊的注释：</strong></p>
<blockquote>
<p>在eclipse中，TODO、FIXME和XXX都会被eclipse的task视图所收集。在项目发布前，检查一下task视图是一个很好的习惯。此外，在eclipse中，我们可自定义自己的特殊注释标签。如在Java中，进入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A[Windows] --&gt; B[Java] </div><div class="line">B --&gt; C[Compiler]</div><div class="line">C --&gt; D[Task Tags]</div></pre></td></tr></table></figure></p>
<p>窗口即可添加特殊标签，默认只有TODO、FIXME和XXX。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java中的特殊注释：&quot;&gt;&lt;a href=&quot;#java中的特殊注释：&quot; class=&quot;headerlink&quot; title=&quot;java中的特殊注释：&quot;&gt;&lt;/a&gt;java中的特殊注释：&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-TODO&quot;&gt;&lt;a href=&quot;#1-TODO
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
      <category term="笔记" scheme="http://www.hansam.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>fastjson基础测试</title>
    <link href="http://www.hansam.cc/2017/07/17/fastjson%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.hansam.cc/2017/07/17/fastjson基础测试/</id>
    <published>2017-07-17T14:57:53.000Z</published>
    <updated>2017-07-18T14:56:12.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fastjson使用测试"><a href="#fastjson使用测试" class="headerlink" title="fastjson使用测试"></a>fastjson使用测试</h3><hr>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cc.hansam.mystudy.json;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author hansam 945210972@qq.com</div><div class="line"> * @date 2017年7月17日下午4:59:16</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class JSONTest &#123;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		Person person = <span class="keyword">new</span> Person();</div><div class="line">		person.setId(<span class="number">1</span>);</div><div class="line">		person.setName(<span class="string">"shi"</span>);</div><div class="line">		person.setAge(<span class="number">22</span>);</div><div class="line">		person.setSex(<span class="string">"male"</span>);</div><div class="line"></div><div class="line">		<span class="comment">// object to jsonstring</span></div><div class="line">		<span class="keyword">String</span> jString = JSON.toJSONString(person);</div><div class="line">		System.out.<span class="built_in">println</span>(jString);</div><div class="line">		</div><div class="line">		<span class="comment">// jsonstring parse to map</span></div><div class="line">		Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = (Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;)JSON.parse(jString);</div><div class="line">		System.out.<span class="built_in">println</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"name"</span>));</div><div class="line"></div><div class="line">		</div><div class="line">		<span class="comment">// jsonstring pare to object</span></div><div class="line">		<span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"&#123;\"age\":22,\"id\":1,\"name\":\"shi\",\"sex\":\"male\",\"dea\":\"male\",\"sasa\":\"male\"&#125;"</span>;</div><div class="line">		Person p = JSON.parseObject(<span class="built_in">str</span>, Person.class);</div><div class="line">		System.out.<span class="built_in">println</span>(p);</div><div class="line">		</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * fastjson 转换key不区分大小写，转换没有明确的对应关系（多对多）</div><div class="line">		 */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结论：</p>
<blockquote>
<p>fastjson 转换key不区分大小写，转换没有明确的对应关系（多对多）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;fastjson使用测试&quot;&gt;&lt;a href=&quot;#fastjson使用测试&quot; class=&quot;headerlink&quot; title=&quot;fastjson使用测试&quot;&gt;&lt;/a&gt;fastjson使用测试&lt;/h3&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight pro
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
      <category term="json" scheme="http://www.hansam.cc/tags/json/"/>
    
  </entry>
  
  <entry>
    <title> 广告投放方式：CPC、CPM、CPA、CPS、CPT</title>
    <link href="http://www.hansam.cc/2017/07/09/%E5%B9%BF%E5%91%8A%E6%8A%95%E6%94%BE%E6%96%B9%E5%BC%8F%EF%BC%9ACPC%E3%80%81CPM%E3%80%81CPA%E3%80%81CPS%E3%80%81CPT/"/>
    <id>http://www.hansam.cc/2017/07/09/广告投放方式：CPC、CPM、CPA、CPS、CPT/</id>
    <published>2017-07-09T10:17:23.000Z</published>
    <updated>2017-07-09T13:36:37.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPC（按点击付费）"><a href="#CPC（按点击付费）" class="headerlink" title="CPC（按点击付费）"></a>CPC（按点击付费）</h3><blockquote>
<p>CPC—英文全称Cost PerClick。CPC是一种点击付费广告，根据广告被点击的次数收费。如关键词广告一般采用这种定价模式，比较典型的有Google的AdSensefor Content、百度联盟的百度竞价广告以及淘宝的直通车广告。</p>
</blockquote>
<h3 id="CPM（按展示付费）"><a href="#CPM（按展示付费）" class="headerlink" title="CPM（按展示付费）"></a>CPM（按展示付费）</h3><blockquote>
<p>CPM—英文全称Cost Per Mille 或者是Cost PerThousandImpression。CPM是一种展示付费广告，只要展示了广告主的广告内容，广告主就为此付费。这种广告的效果不是很好，但是却能给有一定流量的网站、博客带来稳定的收入。</p>
</blockquote>
<h3 id="CPA（按行为付费）"><a href="#CPA（按行为付费）" class="headerlink" title="CPA（按行为付费）"></a>CPA（按行为付费）</h3><blockquote>
<p>CPA—英文全称Cost PerAction。CPA是一种按广告投放实际效果计价方式的广告，即按回应的有效问卷或定单来计费，而不限广告投放量。CPA的计价方式对于网站而言有一定的风险，但若广告投放成功，其收益也比CPM的计价方式要大得多。</p>
</blockquote>
<h3 id="CPS（按销售付费）"><a href="#CPS（按销售付费）" class="headerlink" title="CPS（按销售付费）"></a>CPS（按销售付费）</h3><blockquote>
<p>CPS—英文全称Cost PerSales。CPS是一种以实际销售产品数量来计算广告费用的广告，这种广告更多的适合购物类、导购类、网址导航类的网站，需要精准的流量才能带来转化。凡客的网站联盟是这种广告形式的典型代表。</p>
</blockquote>
<h3 id="CPT（按-时长付费）"><a href="#CPT（按-时长付费）" class="headerlink" title="CPT（按 时长付费）"></a>CPT（按 时长付费）</h3><blockquote>
<p>CPT—英文全称Cost PerTime。CPT是一种以时间来计费的广告，国内很多的网站都是按照“一个月多少钱”这种固定收费模式来收费的，这种广告形式很粗糙，无法保障客户的利益。但是CPT的确是一种很省心的广告，能给你的网站、博客带来稳定的收入。<br>阿里妈妈的按周计费广告和门户网站的包月广告都属于这种CPT广告。<br>相比而言，CPM和CPT对网站有利，而CPC、CPA、CPS则对广告主有利。目前比较流行的计价方式是CPM和CPC，最为流行的则为CPM。</p>
</blockquote>
<h3 id="其他相关内容："><a href="#其他相关内容：" class="headerlink" title="其他相关内容："></a>其他相关内容：</h3><p>1、CPM<br>　　收费最科学的办法是按照有多少人看到你的广告来收费。按访问人次收费已经成为移动广告平台的惯例。CPM（千人成本）指的是广告投放过程中，听到或者看到某广告的每一人平均分担到多少广告成本。传统媒介多采用这种计价方式。在移动广告平台上，CPM取决于“印象”尺度，通常理解为一个人的眼睛在一段固定的时间内注视一个广告的次数。比如说一个内置广告横幅的单价是1元/CPM的话，意味着每一千个人次看到这个Ban-ner的话就收1元，如此类推，10，000人次访问的主页就是10元。至于每CPM的收费究竟是多少，要根据以手机应用的热门程度（即浏览人数）划分价格等级，采取固定费率。国际惯例是每CPM收费从5美元至200美元不等。<br>2、CPC<br>　　以每点击一次计费。这样的方法加上点击率限制可以加强作弊的难度，而且是宣传的最优方式。但是，此类方法就有不少人觉得不公平，比如，虽然浏览者没有点击，但是他已经看到了广告，对于这些看到广告却没有点击的流量来说，广告成了白忙活。有很多手机应用不愿意做这样的广告，据说，是因为传统媒体从来都没有这样干过。<br>3、CPA<br>　　CPA计价方式是指按广告投放实际效果，即按回应的有效问卷或定单来计费，而不限广告投放量。CPA的计价方式对于网站而言有一定的风险，但若广告投放成功，其收益也比CPM的计价方式要大得多。据我所知7天酒店在投放网络广告的时候，有一部分就是这么干的，按照每注册一个会员，给网站付20元。说道收费方式CPM、CPC 、CPA三种收费方式只能比较出哪个更适合你而已。<br>　　无论采用CPM、CPC还是CPA，广告主都可以根据自身产品特性进行选择，这和传统互联网广告是一样的。由于电商行业的快速发展，目前移动广告平台还出现了CPS（按每次购买进行计费）的收费方式，但普遍效果还不够好，原因更多在于移动支付方面还有诸多不便的地方。<br>　　目前国内绝大部分移动广告平台都支持CPM、CPC、CPA计费，在选择移动广告投放时，广告主可更多考虑移动广告平台的稳定性和媒介资源深度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPC（按点击付费）&quot;&gt;&lt;a href=&quot;#CPC（按点击付费）&quot; class=&quot;headerlink&quot; title=&quot;CPC（按点击付费）&quot;&gt;&lt;/a&gt;CPC（按点击付费）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;CPC—英文全称Cost PerClick。CPC
    
    </summary>
    
    
      <category term="百科" scheme="http://www.hansam.cc/tags/%E7%99%BE%E7%A7%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC项目JSP取不到ModelAndView的数据解决</title>
    <link href="http://www.hansam.cc/2017/07/09/SpringMVC%E9%A1%B9%E7%9B%AEJSP%E5%8F%96%E4%B8%8D%E5%88%B0ModelAndView%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%86%B3/"/>
    <id>http://www.hansam.cc/2017/07/09/SpringMVC项目JSP取不到ModelAndView的数据解决/</id>
    <published>2017-07-09T10:11:36.000Z</published>
    <updated>2017-07-09T10:25:59.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用maven构建的springmvc项目EL表达式取不到值-不管是用-msg-还是用JSTL的-都不行"><a href="#使用maven构建的springmvc项目EL表达式取不到值-不管是用-msg-还是用JSTL的-都不行" class="headerlink" title="使用maven构建的springmvc项目EL表达式取不到值,不管是用 ${msg}还是用JSTL的 都不行"></a>使用maven构建的springmvc项目EL表达式取不到值,不管是用 ${msg}还是用JSTL的<c:out value="${msg}"> 都不行</c:out></h3><p>我是用maven自动生成的web.xml文件 如下：</p>
<pre><code>&lt;!DOCTYPE web-app PUBLIC  
&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;  
&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;  

&lt;web-app&gt;  

&lt;/web-app&gt;  
</code></pre><p>但这样的文件不行，需要改成</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  

&lt;web-app&gt;

&lt;/web-app&gt;  
</code></pre><p>重启就OK了，现在上面的两种方法都支持了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用maven构建的springmvc项目EL表达式取不到值-不管是用-msg-还是用JSTL的-都不行&quot;&gt;&lt;a href=&quot;#使用maven构建的springmvc项目EL表达式取不到值-不管是用-msg-还是用JSTL的-都不行&quot; class=&quot;headerl
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java资源绑定（ResourceBundle）示例</title>
    <link href="http://www.hansam.cc/2017/07/04/Java%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%EF%BC%88ResourceBundle%EF%BC%89%E7%A4%BA%E4%BE%8B/"/>
    <id>http://www.hansam.cc/2017/07/04/Java资源绑定（ResourceBundle）示例/</id>
    <published>2017-07-04T15:42:00.000Z</published>
    <updated>2017-07-09T13:30:25.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java-util-ResourceBundle"><a href="#java-util-ResourceBundle" class="headerlink" title="java.util.ResourceBundle"></a>java.util.ResourceBundle</h3><blockquote>
<p>是用于国际化（多语言）的库。它能够根据为系统配置的默认区域设置返回消息。当开发适用于世界各地使用的系统时，就可以使用这样的功能。</p>
</blockquote>
<h3 id="1-它是如何工作的？"><a href="#1-它是如何工作的？" class="headerlink" title="1.它是如何工作的？"></a>1.它是如何工作的？</h3><blockquote>
<p>库是基于在属性命名中使用的区域设置和名称后缀读取属性文件。例如，考虑一个名为MyLabels_en_US.properties的标签文件。当Locale设置表示US-English的en_US时，此文件由ResourceBundle程序读取。<br>区域设置表示具有其属性的区域或位置。Locale通常用于使用我们的应用程序维护有关客户端的详细信息。 区域设置包含要用于相应位置的位置和语言的属性。 因此，Locale通过确定用户所属的位置来帮助ResourceBundle选择正确的标签文件。</p>
</blockquote>
<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h3><pre><code>让我们看看下面的例子，以更清楚地说明这个问题：
MyLabels_en_US.properties 文件有以下内容 -
how_are_you = How are you?
Java
MyLabels_ms_MY.properties 文件有以下内容 -
how_are_you = apa khabar
Java
完整的程序代码如下 -
</code></pre><p>

<pre><code>import java.util.Locale;
import java.util.ResourceBundle;

public class Application {

    public static void main(String[] args) {

        // en_US
        System.out.println(&quot;Current Locale: &quot; + Locale.getDefault());
        ResourceBundle mybundle = ResourceBundle.getBundle(&quot;MyLabels&quot;);

        // read MyLabels_en_US.properties
        System.out.println(&quot;Say how are you in US English: &quot; + mybundle.getString(&quot;how_are_you&quot;));

        Locale.setDefault(new Locale(&quot;ms&quot; &quot;MY&quot;));

        // read MyLabels_ms_MY.properties
        System.out.println(&quot;Current Locale: &quot; + Locale.getDefault());
        mybundle = ResourceBundle.getBundle(&quot;MyLabels&quot;);
        System.out.println(&quot;Say how are you in Malaysian Malaya language: &quot; + mybundle.getString(&quot;how_are_you&quot;));

    }

}
</code></pre></p><p>Java在执行此代码时，得到以下输出：</p>
<pre><code>Current Locale: en_US
Say how are you in US English: How are you?
Current Locale: ms_MY
Say how are you in Malaysian Malaya language: apa khabar
Java
</code></pre><p>在输出中可以看到，取决于为Locale集设置的默认值。此实用程序主要用于Web应用程序，其中Web浏览器有助于了解远程用户的区域设置。这使得尽可能以特定语言显示网站成为可能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java-util-ResourceBundle&quot;&gt;&lt;a href=&quot;#java-util-ResourceBundle&quot; class=&quot;headerlink&quot; title=&quot;java.util.ResourceBundle&quot;&gt;&lt;/a&gt;java.util.Reso
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中堆内存和栈内存详解</title>
    <link href="http://www.hansam.cc/2017/07/04/Java%E4%B8%AD%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.hansam.cc/2017/07/04/Java中堆内存和栈内存详解/</id>
    <published>2017-07-04T15:27:43.000Z</published>
    <updated>2017-07-09T13:47:30.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构的栈和堆"><a href="#数据结构的栈和堆" class="headerlink" title="数据结构的栈和堆"></a>数据结构的栈和堆</h2><hr>
<blockquote>
<p>首先在数据结构上要知道堆栈，尽管我们这么称呼它，但实际上堆栈是两种数据结构：堆和栈。</p>
</blockquote>
<p><strong>堆和栈都是一种数据项按序排列的数据结构</strong></p>
<p><strong>栈就像装数据的桶或箱子</strong></p>
<blockquote>
<p>我们先从大家比较熟悉的栈说起吧，它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我们首先要移开压在它上面的物体（放入的比较晚的物体）。</p>
</blockquote>
<p><strong>堆像一棵倒过来的树</strong></p>
<blockquote>
<p>而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>
</blockquote>
<h2 id="Java中内存分配策略及堆和栈的比较"><a href="#Java中内存分配策略及堆和栈的比较" class="headerlink" title="Java中内存分配策略及堆和栈的比较"></a>Java中内存分配策略及堆和栈的比较</h2><h3 id="1-内存分配策略"><a href="#1-内存分配策略" class="headerlink" title="1 内存分配策略"></a>1 内存分配策略</h3><p>　　按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的. </p>
<p>　　静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求. </p>
<p>　　栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。 </p>
<p>　　静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放. </p>
<h3 id="2-堆和栈的比较"><a href="#2-堆和栈的比较" class="headerlink" title="2 堆和栈的比较"></a>2 堆和栈的比较</h3><p>　　上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈: </p>
<p>　　从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的: </p>
<p>　　在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时. </p>
<p>　　堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~). </p>
<h3 id="3-JVM中的堆和栈"><a href="#3-JVM中的堆和栈" class="headerlink" title="3 JVM中的堆和栈"></a>3 JVM中的堆和栈</h3><p>　　JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 </p>
<p>　　我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的. </p>
<p>　　从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。 </p>
<p>　　每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。 </p>
<p>　　</p>
<h2 id="Java-中的堆和栈"><a href="#Java-中的堆和栈" class="headerlink" title="Java 中的堆和栈"></a>Java 中的堆和栈</h2><p>　　Java把内存划分成两种：一种是栈内存，一种是堆内存。 </p>
<p>　　在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 </p>
<p>　　当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 </p>
<p>　　堆内存用来存放由new创建的对象和数组。 </p>
<p>　　在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 </p>
<p>　　在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 </p>
<p>　　引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 </p>
<h3 id="具体的说："><a href="#具体的说：" class="headerlink" title="具体的说："></a>具体的说：</h3><p>　　</p>
<blockquote>
<p>　　栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 </p>
<p>　　Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p>
<p>　　栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int,<br>short, long, byte, float, double, boolean, char)和对象句柄。</p>
</blockquote>
<p>　　栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： </p>
<p>　　int a = 3; </p>
<p>　　int b = 3; </p>
<p>　　编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据结构的栈和堆&quot;&gt;&lt;a href=&quot;#数据结构的栈和堆&quot; class=&quot;headerlink&quot; title=&quot;数据结构的栈和堆&quot;&gt;&lt;/a&gt;数据结构的栈和堆&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;首先在数据结构上要知道堆栈，尽管我们这么称呼它，但实际上
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>my-first-blog</title>
    <link href="http://www.hansam.cc/2017/05/02/my-first-blog/"/>
    <id>http://www.hansam.cc/2017/05/02/my-first-blog/</id>
    <published>2017-05-02T01:13:21.000Z</published>
    <updated>2017-07-09T10:07:31.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是我的第一篇博客"><a href="#这是我的第一篇博客" class="headerlink" title="这是我的第一篇博客"></a>这是我的第一篇博客</h2><hr>
<blockquote>
<p>我此时正在图书馆，准备毕业答辩的相关事宜。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这是我的第一篇博客&quot;&gt;&lt;a href=&quot;#这是我的第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;这是我的第一篇博客&quot;&gt;&lt;/a&gt;这是我的第一篇博客&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我此时正在图书馆，准备毕业答辩的相关事宜。&lt;/p
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.hansam.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
