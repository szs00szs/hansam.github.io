<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hansam Blogs</title>
  <subtitle>you got a dream,you got to protect it :)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.hansam.cc/"/>
  <updated>2018-02-07T07:17:58.740Z</updated>
  <id>http://www.hansam.cc/</id>
  
  <author>
    <name>Hansam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式六大原则概述</title>
    <link href="http://www.hansam.cc/2018/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.hansam.cc/2018/02/07/设计模式六大原则概述/</id>
    <published>2018-02-07T07:10:31.000Z</published>
    <updated>2018-02-07T07:17:58.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。只有精通了设计模式，才敢说真正理解了软件工程。可以说，设计模式是每一个架构师所必备的技能之一。想要精通设计模式，必须要先搞清楚设计模式的六大原则。</p>
</blockquote>
<hr>
<h4 id="1-单一职责原则（Single-Responsibility-Principle，简称SRP-）"><a href="#1-单一职责原则（Single-Responsibility-Principle，简称SRP-）" class="headerlink" title="1.单一职责原则（Single Responsibility Principle，简称SRP ）"></a>1.单一职责原则（Single Responsibility Principle，简称SRP ）</h4><ul>
<li><p>核心思想：应该有且仅有一个原因引起类的变更。</p>
</li>
<li><p>问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。</p>
</li>
<li><p>好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。</p>
</li>
<li><p>需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。</p>
</li>
</ul>
<hr>
<h4 id="2-里氏替换原则（Liskov-Substitution-Principle-简称LSP）"><a href="#2-里氏替换原则（Liskov-Substitution-Principle-简称LSP）" class="headerlink" title="2.里氏替换原则（Liskov Substitution Principle,简称LSP）"></a>2.里氏替换原则（Liskov Substitution Principle,简称LSP）</h4><ul>
<li><p>核心思想：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。</p>
</li>
<li><p>通俗来讲：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。</p>
</li>
<li><p>好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。</p>
</li>
<li><p>需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。</p>
</li>
</ul>
<hr>
<h4 id="3-依赖倒置原则（Dependence-Inversion-Principle-简称DIP）"><a href="#3-依赖倒置原则（Dependence-Inversion-Principle-简称DIP）" class="headerlink" title="3.依赖倒置原则（Dependence Inversion Principle,简称DIP）"></a>3.依赖倒置原则（Dependence Inversion Principle,简称DIP）</h4><ul>
<li><p>核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；</p>
</li>
<li><p>说明：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。</p>
</li>
<li><p>通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。</p>
</li>
<li><p>问题描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>
</li>
<li><p>解决方案：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
</li>
<li><p>好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。</p>
</li>
</ul>
<hr>
<h4 id="4-接口隔离原则（Interface-Segregation-Principle-简称ISP）"><a href="#4-接口隔离原则（Interface-Segregation-Principle-简称ISP）" class="headerlink" title="4.接口隔离原则（Interface Segregation Principle,简称ISP）"></a>4.接口隔离原则（Interface Segregation Principle,简称ISP）</h4><ul>
<li><p>核心思想：类间的依赖关系应该建立在最小的接口上</p>
</li>
<li><p>通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p>
</li>
<li><p>问题描述：类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p>
</li>
<li><p>需注意：<br>&emsp;&emsp;<strong>接口尽量小，但是要有限度</strong>。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。<br>&emsp;&emsp;<strong>提高内聚，减少对外交互。</strong>使接口用最少的方法去完成最多的事情。<br>&emsp;&emsp;<strong>为依赖接口的类定制服务。</strong>只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</p>
</li>
</ul>
<hr>
<h4 id="5-迪米特法则（Law-of-Demeter-简称LoD）"><a href="#5-迪米特法则（Law-of-Demeter-简称LoD）" class="headerlink" title="5.迪米特法则（Law of Demeter,简称LoD）"></a>5.迪米特法则（Law of Demeter,简称LoD）</h4><ul>
<li><p>核心思想：类间解耦。</p>
</li>
<li><p>通俗来讲： 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：<strong>低耦合，高内聚。</strong>无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p>
</li>
</ul>
<hr>
<h4 id="6-开放封闭原则（Open-Close-Principle-简称OCP"><a href="#6-开放封闭原则（Open-Close-Principle-简称OCP" class="headerlink" title="6.开放封闭原则（Open Close Principle,简称OCP)"></a>6.开放封闭原则（Open Close Principle,简称OCP)</h4><ul>
<li><p>核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。</p>
</li>
<li><p>通俗来讲： 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</p>
</li>
</ul>
<hr>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><ol>
<li>单一职责原则告诉我们实现类要职责单一；</li>
<li>里氏替换原则告诉我们不要破坏继承体系；</li>
<li>依赖倒置原则告诉我们要面向接口编程；</li>
<li>接口隔离原则告诉我们在设计接口的时候要精简单一；</li>
<li>迪米特法则告诉我们要降低耦合。</li>
<li>而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总结一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。<br><br><br><img src="https://upload-images.jianshu.io/upload_images/1457495-90f01fcf3d251455.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/543" alt="此处输入图片的描述"><br>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。<br><br><br><img src="https://upload-images.jianshu.io/upload_images/1457495-b181bdb675ab3fa6.png?imageMogr2/auto-orient/" alt="此处输入图片的描述"><br>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p>
<p>原文引用：<a href="https://www.jianshu.com/p/807bc228dbc2" target="_blank" rel="external">https://www.jianshu.com/p/807bc228dbc2</a><br>來源：简书</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设
    
    </summary>
    
    
      <category term="软件工程" scheme="http://www.hansam.cc/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA快捷键整理</title>
    <link href="http://www.hansam.cc/2018/02/07/Intellij-IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/"/>
    <id>http://www.hansam.cc/2018/02/07/Intellij-IDEA快捷键整理/</id>
    <published>2018-02-07T04:03:08.000Z</published>
    <updated>2018-02-07T04:08:32.651Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Intellij首当其冲的当然就是Intelligence智能！
</code></pre><h4 id="实用快捷键"><a href="#实用快捷键" class="headerlink" title="实用快捷键"></a>实用快捷键</h4><hr>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+/</td>
<td>注释（//）</td>
</tr>
<tr>
<td>Ctrl+Shift+/</td>
<td>注释（/<em>…</em>/）</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>复制行</td>
</tr>
<tr>
<td>Ctrl+X</td>
<td>删除行</td>
</tr>
<tr>
<td>Alt+Enter</td>
<td>快速修复</td>
</tr>
<tr>
<td>Alt+/</td>
<td>代码提示</td>
<td></td>
</tr>
<tr>
<td>Ctrl+G</td>
<td>定位某一行</td>
</tr>
<tr>
<td>Shift+F6</td>
<td>重命名</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>替换文本</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>查找文本</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>最近打开的文件</td>
</tr>
<tr>
<td>Ctrl+J</td>
<td>自动代码</td>
</tr>
<tr>
<td>Ctrl+Alt+O</td>
<td>组织导入</td>
</tr>
<tr>
<td>Ctrl+Alt+L</td>
<td>格式化代码</td>
<td></td>
</tr>
<tr>
<td>Ctrl+Shift+U</td>
<td>大小写转化</td>
</tr>
<tr>
<td>Ctrl+Shift+减号/加号</td>
<td>全局折叠/展开代码</td>
</tr>
<tr>
<td>Ctrl+&gt;</td>
<td>局部折叠/展开代码</td>
</tr>
<tr>
<td>Ctrl+Shift+&gt;</td>
<td>局部折叠代码</td>
</tr>
<tr>
<td>Ctrl+F12</td>
<td>查看当前类的所有方法</td>
</tr>
<tr>
<td>Alt+F7</td>
<td>找类或方法的使用</td>
</tr>
<tr>
<td>Ctrl+Shift+A</td>
<td>查找所有Intellij的命令</td>
</tr>
<tr>
<td>fori/sout/psvm+Tab</td>
<td>循环、System.out、main样板代码</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><hr>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt+Enter</td>
<td>自动修正</td>
</tr>
<tr>
<td>Ctrl+Shift+Enter</td>
<td>自动补全末尾的字符</td>
</tr>
<tr>
<td>Ctrl+N</td>
<td>查找类</td>
</tr>
<tr>
<td>Ctrl+Shift+N</td>
<td>查找文件</td>
</tr>
<tr>
<td>Ctrl+Alt+L</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl+Alt+O</td>
<td>优化导入的类和包</td>
</tr>
<tr>
<td>Alt+Insert</td>
<td>生成代码(如get,set方法,构造函数等)</td>
</tr>
<tr>
<td>Ctrl+E/Alt+Shift+C</td>
<td>最近更改的代码</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>替换文本</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>查找文本</td>
</tr>
<tr>
<td>Ctrl+Space</td>
<td>基本代码提示</td>
</tr>
<tr>
<td>Ctrl+Shift+Space</td>
<td>智能补全代码</td>
</tr>
<tr>
<td>Ctrl+Alt+Space</td>
<td>类名或接口名提示</td>
</tr>
<tr>
<td>Ctrl+P</td>
<td>方法参数提示</td>
</tr>
<tr>
<td>Ctrl+Shift+Alt+T</td>
<td>重构功能</td>
</tr>
<tr>
<td>Ctrl+Shift+Alt+N</td>
<td>查找类中的方法或变量</td>
</tr>
<tr>
<td>Alt+Shift+C</td>
<td>对比最近修改的代码</td>
</tr>
<tr>
<td>Shift+F6</td>
<td>重命名</td>
</tr>
<tr>
<td>Ctrl+X</td>
<td>删除行</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>复制行</td>
</tr>
<tr>
<td>Ctrl+/</td>
<td>注释（//）</td>
</tr>
<tr>
<td>Ctrl+Shift+/</td>
<td>注释（/<em>…</em>/）</td>
</tr>
<tr>
<td>Ctrl+J</td>
<td>自动代码</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>最近打开的文件</td>
</tr>
<tr>
<td>Ctrl+H</td>
<td>显示类结构图</td>
</tr>
<tr>
<td>Ctrl+Q</td>
<td>显示注释文档</td>
</tr>
<tr>
<td>Alt+F1</td>
<td>查找代码所在位置</td>
</tr>
<tr>
<td>Alt+1</td>
<td>快速打开或隐藏工程面板</td>
</tr>
<tr>
<td>Ctrl+Alt+left/right</td>
<td>返回至上次浏览的位置</td>
</tr>
<tr>
<td>Alt+left/right</td>
<td>切换代码视图</td>
</tr>
<tr>
<td>Alt+Up/Down</td>
<td>在方法间快速移动定位</td>
</tr>
<tr>
<td>Ctrl+Shift+Up/Down</td>
<td>代码向上/下移动。</td>
</tr>
<tr>
<td>F2/Shift+F2</td>
<td>高亮错误或警告快速定位</td>
</tr>
<tr>
<td>Ctrl+Shift+F7</td>
<td>高亮显示所有该文本，按Esc高亮消失。</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>选中代码</td>
</tr>
<tr>
<td>Alt+F3</td>
<td>逐个往下查找相同文本，并高亮显示。</td>
</tr>
<tr>
<td>Ctrl+Up/Down</td>
<td>光标跳转到第一行或最后一行下</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>快速打开光标处的类或方法</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Intellij首当其冲的当然就是Intelligence智能！
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;实用快捷键&quot;&gt;&lt;a href=&quot;#实用快捷键&quot; class=&quot;headerlink&quot; title=&quot;实用快捷键&quot;&gt;&lt;/a&gt;实用快捷键&lt;/h4&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://www.hansam.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>天使投资、VC、PE 的区别</title>
    <link href="http://www.hansam.cc/2017/11/06/%E5%A4%A9%E4%BD%BF%E6%8A%95%E8%B5%84%E3%80%81VC%E3%80%81PE%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.hansam.cc/2017/11/06/天使投资、VC、PE 的区别/</id>
    <published>2017-11-06T11:52:55.000Z</published>
    <updated>2017-11-06T12:57:28.363Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，天使／VC／PE属于私募基金，体现了企业从创业初期到IPO之前的整个融资过程，属于一级市场，到公司上市后，企业走向二级市场，叫做公开募股，先看图：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/myimg/20171106/01.jpg" alt=""></h2><p>1）先从公司创业期的融资说起：一般来说，我们经常听到的就是风险投资（Venture Capital，简称为VC）和天使。天使：企业刚刚开始创立，进来的是天使。这个阶段，大多企业基本还是赔钱的。VC：传统来说，这也基本已经盈利了，才会引入VC，但现在好的项目也不一定，例如近期的知乎和摩拜。因此，当前阶段还是有一定风险的。所以叫风险投资。该过程可能有多轮，也就是我们常听的A轮、B轮、C轮和D轮，每轮可能有一个领投，多个跟投。</p>
<p>2）上市前的融资：企业上市，也就是IPO（暂且先这样理解），这个阶段经常听到的是私募股权投资Private Equity，简称为PE。上市代表有巨大盈利空间，这个阶段的PE可以说是来分蛋糕的，也叫Pre-IPO。对投资方来说，此时的投资有一定保障，但不代表没有风险。</p>
<p>3）上市后的融资：公司上市，也叫IPO，即首次公开募股Initial Public Offerings（IPO）指企业通过证券交易所首次公开向投资者增发股票，以期募集用于企业发展资金的过程。股票上市后融资差不多就是在二级市场交易了，但也不排除一级市场。</p>
<hr>
<h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p><img src="/myimg/20171106/02.jpg" alt=""><br><img src="/myimg/20171106/03.jpg" alt=""><br><img src="/myimg/20171106/04.jpg" alt=""><br><img src="/myimg/20171106/05.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，天使／VC／PE属于私募基金，体现了企业从创业初期到IPO之前的整个融资过程，属于一级市场，到公司上市后，企业走向二级市场，叫做公开募股，先看图：&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="金融" scheme="http://www.hansam.cc/tags/%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>javascript 基础 js类和原型</title>
    <link href="http://www.hansam.cc/2017/08/09/javascript%20%E5%9F%BA%E7%A1%80%20js%20%E7%B1%BB%E5%92%8C%E5%8E%9F%E5%9E%8B/"/>
    <id>http://www.hansam.cc/2017/08/09/javascript 基础 js 类和原型/</id>
    <published>2017-08-09T14:28:40.000Z</published>
    <updated>2017-08-07T14:35:30.290Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp; 一个函数可以看成一个类，原型是所有类都有的一个属性，原型的作用就是给这个类的每一个对象都添加一个统一的方法。</p>
<hr>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span> <span class="attr">xml:lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span>&gt;</span><span class="actionscript"></span></div><div class="line">    <span class="comment">//声明一个类</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,age)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.name=name;</div><div class="line">        <span class="keyword">this</span>.age=age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//使用原型给类添加方法</span></div><div class="line">    Person.prototype.show=<span class="function"><span class="keyword">function</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        alert(<span class="string">"我叫"</span>+<span class="keyword">this</span>.name+<span class="string">",今年"</span>+<span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建两个对象</span></div><div class="line">    <span class="keyword">var</span> person1 =<span class="keyword">new</span> Person(<span class="string">'张三'</span>,<span class="number">20</span>);</div><div class="line">    <span class="keyword">var</span> person2 =<span class="keyword">new</span> Person(<span class="string">'李四'</span>,<span class="number">23</span>);</div><div class="line">    <span class="comment">//调用原型里面的方法</span></div><div class="line">    person1.show();</div><div class="line">    person2.show();</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">     </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp; 一个函数可以看成一个类，原型是所有类都有的一个属性，原型的作用就是给这个类的每一个对象都添加一个统一的方法。&lt;/p&gt;
&lt;hr&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.hansam.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java中的数字格式化类DecimalFormat</title>
    <link href="http://www.hansam.cc/2017/08/08/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BBDecimalFormat/"/>
    <id>http://www.hansam.cc/2017/08/08/Java中的数字格式化类DecimalFormat/</id>
    <published>2017-08-08T14:24:03.000Z</published>
    <updated>2017-08-07T14:36:03.632Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp; 我们经常要将数字进行格式化，比如取2位小数，这是最常见的。Java 提供 DecimalFormat类，帮你用最快的速度将数字格式化为你需要的样子。下面是一个例子：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.text.DecimalFormat;</div><div class="line">　　</div><div class="line">public class TestNumberFormat&#123;</div><div class="line">　　</div><div class="line">　　public static void main(<span class="keyword">String</span>[] args)&#123;</div><div class="line">　　　　double <span class="built_in">pi</span>=<span class="number">3.1415927</span>;　<span class="comment">//圆周率</span></div><div class="line">　　　　<span class="comment">//取一位整数</span></div><div class="line">　　　　<span class="keyword">System</span>.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"0"</span>).<span class="keyword">format</span>(<span class="built_in">pi</span>));　　　<span class="comment">//3</span></div><div class="line">　　　　<span class="comment">//取一位整数和两位小数</span></div><div class="line">　　　　<span class="keyword">System</span>.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"0.00"</span>).<span class="keyword">format</span>(<span class="built_in">pi</span>));　<span class="comment">//3.14</span></div><div class="line">　　　　<span class="comment">//取两位整数和三位小数，整数不足部分以0填补。</span></div><div class="line">　　　　<span class="keyword">System</span>.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"00.000"</span>).<span class="keyword">format</span>(<span class="built_in">pi</span>));<span class="comment">// 03.142</span></div><div class="line">　　　　<span class="comment">//取所有整数部分</span></div><div class="line">　　　　<span class="keyword">System</span>.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"#"</span>).<span class="keyword">format</span>(<span class="built_in">pi</span>));　　　<span class="comment">//3</span></div><div class="line">　　　　<span class="comment">//以百分比方式计数，并取两位小数</span></div><div class="line">　　　　<span class="keyword">System</span>.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"#.##%"</span>).<span class="keyword">format</span>(<span class="built_in">pi</span>));　<span class="comment">//314.16%</span></div><div class="line">　　</div><div class="line">　　　　long c=<span class="number">299792458</span>;　　<span class="comment">//光速</span></div><div class="line">　　　　<span class="comment">//显示为科学计数法，并取五位小数</span></div><div class="line">　　　　<span class="keyword">System</span>.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"#.#####E0"</span>).<span class="keyword">format</span>(c));　<span class="comment">//2.99792E8</span></div><div class="line">　　　　<span class="comment">//显示为两位整数的科学计数法，并取四位小数</span></div><div class="line">　　　　<span class="keyword">System</span>.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"00.####E0"</span>).<span class="keyword">format</span>(c));　<span class="comment">//29.9792E7</span></div><div class="line">　　　　<span class="comment">//每三位以逗号进行分隔。</span></div><div class="line">　　　　<span class="keyword">System</span>.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">",###"</span>).<span class="keyword">format</span>(c));　　　<span class="comment">//299,792,458</span></div><div class="line">　　　　<span class="comment">//将格式嵌入文本</span></div><div class="line">　　　　<span class="keyword">System</span>.out.println(<span class="keyword">new</span> DecimalFormat(<span class="string">"光速大小为每秒,###米。"</span>).<span class="keyword">format</span>(c));</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>DecimalFormat 类主要靠 # 和 0 两种占位符号来指定数字长度。0 表示如果位数不足则以 0 填充，# 表示只要有可能就把数字拉上这个位置。上面的例子包含了差不多所有的基本用法，如果你想了解更多，请参考 DecimalFormat 类的文档。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp; 我们经常要将数字进行格式化，比如取2位小数，这是最常见的。Java 提供 DecimalFormat类，帮你用最快的速度将数字格式化为你需要的样子。下面是一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight gauss&quot;&gt;&lt;table&gt;&lt;tr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简述负载均衡和CDN技术</title>
    <link href="http://www.hansam.cc/2017/08/07/%E7%AE%80%E8%BF%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8CCDN%E6%8A%80%E6%9C%AF/"/>
    <id>http://www.hansam.cc/2017/08/07/简述负载均衡和CDN技术/</id>
    <published>2017-08-07T14:17:12.000Z</published>
    <updated>2017-08-07T14:36:07.285Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;曾经见到知乎上有人问“为什么像facebook这类的网站需要上千个工程师维护？”，下面的回答多种多样，但总结起来就是：一个高性能的web系统需要从无数个角度去考虑他，大到服务器的布局，小到软件中某个文件的实现，甚至于某个循环内的运算如果出现不严谨都可能导致全盘崩溃。</p>
<p>&emsp;上面提到web性能优化需要多个角度去考虑，我们无法考虑到所有的优化细节，但可以从我们已知的层面去优化，我们就先从网络层面说起。</p>
<hr>
<h3 id="网络请求路径"><a href="#网络请求路径" class="headerlink" title="网络请求路径:"></a>网络请求路径:</h3><p>（客户端输入URL定位符）→（DNS服务器寻找映射）→（进入服务器，处理数据）→（返回数据至客户端）</p>
<p>在这个用例中我们可以很清晰的看出网络请求到返回的过程，虽然非常抽象，但足够我们以他为基础来进行优化了。</p>
<hr>
<h3 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1.负载均衡"></a>1.负载均衡</h3><p>&emsp;BOSS一次给了小明好多项任务，小明发现怎么安排时间也做不完，于是乎他盯上了在旁边偷偷看电影的小强，小强突然觉得背后有一股凉气，一回头小明一脸坏笑看着他，“这几个任务交给你，晚上请你吃饭，要不然…嘿嘿嘿”，小强虽然不情愿，但是在小明的请求（要挟）下，只能服从。第二天，小明顺利的完成了任务，给小强买了袋辣条。</p>
<p>&emsp;在计算机上负载均衡也类似如此，我们的大BOSS客户端将请求发送至服务器，然而一台服务器是无法承受很高的并发量的，我们就会将请求转发到其他服务器，当然真正的负载均衡架构并不是由一台server转发的另一台server，而在客户端与服务器端中间加入了一个负责分配请求的负载均衡硬件（软件）。</p>
<hr>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>&emsp;名词：DNS是客户端发送请求中一个非常重要的中转，他的作用是将用户请求的URL映射为具体的IP地址，全世界有13台根服务器，但通常为我们进行域名解析的并不是根服务器，而是直接访问我们的 LDNS（Local DNS Server），通常由网络运营商维护。</p>
<p>&emsp;最早的负载均衡就是利用搭建本地DNS服务器实现的，实现方式简单易懂，为同一个主机名分配多个映射，可采用轮循，随机等方式分配请求。看上去没什么问题，但是在使用过程中会发现，如果其中一个地址down机，我们是无法及时发现的，如果有用户被分配到这个主机就会出现访问失败的状况，同时我们也无法判断每个server的负载，可能会出现，某个server几乎闲置，另外一个server负载压力极高的情况。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/5e4d414cgw1er7cs8cplij20ji02fglw.jpg" alt="此处输入图片的描述"></p>
<hr>
<h4 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h4><p>&emsp;名词：负载均衡器（Load Balancer），负载均衡器通常作为独立的硬件置于客户端与服务器之间。</p>
<p>&emsp;负载均衡设备拥有非常好的负载均衡性能，他拥有众多的负载均衡策略（权重，动态比率，最快模式，最小连接数等），可以保证以相对较优的方式分配请求，不过好的东西总是有代价的，那就是价格，一台负载均衡器的售价往往高达十几万甚至几十万，许多企业并不愿意为它买单。</p>
<hr>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>&emsp;名词：Nginx。高性能，轻量级，已经成了人们对Nginx的第一印象，Nginx可作为HTTP服务器，在处理高并发请求的时候拥有比现在主流的Apache服务器更高的性能，同时Nginx也是一个优秀的反向代理服务器。</p>
<p>&emsp;第一次听到“反向代理”，可能有些陌生，但如果了解与之对应的正向代理就很好理解了，正向代理通常由客户端主动链接，比如我们的科学上网方式就是使用正向代理，以达到间接访问网站的目的，而反向代理在服务器端，无需主动链接，当我们访问拥有反向代理的网站时，实际访问的是其反向代理服务器，而非真正的服务器，当请求到达反向代理服务器时，反向代理服务器再将请求转发至服务器。反向代理是实现负载均衡的主流手段之一，通常使用Nginx等服务器搭建，Nginx同样拥有众多的分配策略，以保证平均分配压力。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/5e4d414cgw1er7cs8rp0xj20k002jaad.jpg" alt="此处输入图片的描述"></p>
<hr>
<h4 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h4><p><img src="http://ww4.sinaimg.cn/mw690/5e4d414cgw1er7ciyt99rj209h09u3ys.jpg" alt="此处输入图片的描述"></p>
<hr>
<h4 id="BIGIP（硬件）负载均衡"><a href="#BIGIP（硬件）负载均衡" class="headerlink" title="BIGIP（硬件）负载均衡"></a>BIGIP（硬件）负载均衡</h4><p><img src="http://ww1.sinaimg.cn/mw690/5e4d414cgw1er7ciz9j3fj20eg0ejq42.jpg" alt="此处输入图片的描述"></p>
<hr>
<h3 id="2-CDN"><a href="#2-CDN" class="headerlink" title="2.CDN"></a>2.CDN</h3><p>&emsp;视频总在缓冲，图片各种加载不出来，几年前是再正常不过的事了，在当时大家也没觉得是回事，但把这种情况放在现在，我想人们绝对直接就小红叉了吧，那么我们如何避免这样的情况呢？这就是我要说的，内容分发网络（Content Delivery Network），简称：CDN。</p>
<p>&emsp;CDN简单的来说就是存储一些静态文件的一台或多台服务器，通过复制，缓存等方式，将文件保存其中。</p>
<h4 id="1-哪些是静态文件？"><a href="#1-哪些是静态文件？" class="headerlink" title="1.哪些是静态文件？"></a>1.哪些是静态文件？</h4><blockquote>
<p>css，html，图片，媒体都属于静态文件，也就是说用户发送的请求不会影响静态文件的内容，而jsp，php等文件就不属于静态文件，因为他们的内容会因我们的请求而发生改变。</p>
</blockquote>
<h4 id="2-CDN如何实现加速？"><a href="#2-CDN如何实现加速？" class="headerlink" title="2.CDN如何实现加速？"></a>2.CDN如何实现加速？</h4><blockquote>
<p>通常情况下，我们所要的数据都是从主服务器中获取，但假如我们的主服务器在南方，而访问用户在北方，那么访问速度就会相对变慢，变慢的原因有很多，例如传输距离，运营商，带宽等等因素，而使用CDN技术的话，我们会将CDN节点分布在各地，当用户发送请求到达服务器时，服务器会根据用户的区域信息，为用户分配最近的CDN服务器。</p>
</blockquote>
<h4 id="3-CDN数据从哪里来？"><a href="#3-CDN数据从哪里来？" class="headerlink" title="3.CDN数据从哪里来？"></a>3.CDN数据从哪里来？</h4><blockquote>
<p>复制，缓存，CDN服务器可以在用户请求后缓存文件，也可以主动抓取主服务器内容。</p>
</blockquote>
<p>分布在各地的CDNS：<br><img src="http://ww2.sinaimg.cn/mw690/5e4d414cgw1er7cizt3znj20dw099756.jpg" alt="此处输入图片的描述"></p>
<hr>
<p>原文引用：<a href="http://www.cnblogs.com/mokafamily/p/4402366.html" target="_blank" rel="external">http://www.cnblogs.com/mokafamily/p/4402366.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;曾经见到知乎上有人问“为什么像facebook这类的网站需要上千个工程师维护？”，下面的回答多种多样，但总结起来就是：一个高性能的web系统需要从无数个角度去考虑他，大到服务器的布局，小到软件中某个文件的实现，甚至于某个循环内的运算如果出现不严谨都可能导致全盘崩
    
    </summary>
    
    
      <category term="架构" scheme="http://www.hansam.cc/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>反向代理与正向代理区别</title>
    <link href="http://www.hansam.cc/2017/07/30/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.hansam.cc/2017/07/30/反向代理与正向代理区别/</id>
    <published>2017-07-30T02:46:07.000Z</published>
    <updated>2018-02-07T07:13:27.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h3><blockquote>
<p>&emsp;<strong>代理</strong>（英语：Proxy），也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。<br>&emsp;提供代理服务的电脑系统或其它类型的网络终端称为代理服务器（英文：Proxy Server）。</p>
</blockquote>
<hr>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><blockquote>
<p>&emsp;A同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。</p>
<p>&emsp;我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 <a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a> 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。 </p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20170516145748876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcyMTAxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="正向代理模型"></p>
<hr>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><blockquote>
<p>&emsp;大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理。客户不知道真正提供服务人的是谁。</p>
<p>&emsp;反向代理隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。 </p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20170516150039596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcyMTAxMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="反向代理模型"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是代理&quot;&gt;&lt;a href=&quot;#什么是代理&quot; class=&quot;headerlink&quot; title=&quot;什么是代理&quot;&gt;&lt;/a&gt;什么是代理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&lt;strong&gt;代理&lt;/strong&gt;（英语：Proxy），也称网络代理，是一
    
    </summary>
    
    
      <category term="架构" scheme="http://www.hansam.cc/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>WebService服务的使用</title>
    <link href="http://www.hansam.cc/2017/07/30/WebService%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.hansam.cc/2017/07/30/WebService服务的使用/</id>
    <published>2017-07-30T02:19:39.000Z</published>
    <updated>2017-07-30T02:22:44.785Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用wsimport生成客户端java类</strong></p>
<blockquote>
<p>wsimport -keep -p cc <a href="http://192.168.1.124:1533/ws/shi?wsdl" target="_blank" rel="external">http://192.168.1.124:1533/ws/shi?wsdl</a></p>
</blockquote>
<p>使用生成的客户端调用服务<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns:wsu</span>=<span class="string">"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"</span> <span class="attr">xmlns:wsp</span>=<span class="string">"http://www.w3.org/ns/ws-policy"</span> <span class="attr">xmlns:wsp1_2</span>=<span class="string">"http://schemas.xmlsoap.org/ws/2004/09/policy"</span> <span class="attr">xmlns:wsam</span>=<span class="string">"http://www.w3.org/2007/05/addressing/metadata"</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/soap/"</span> <span class="attr">xmlns:tns</span>=<span class="string">"http://support.ws.integration.server.odb.product.uinnova.com/"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/"</span> <span class="attr">targetNamespace</span>=<span class="string">"http://support.ws.integration.server.odb.product.uinnova.com/"</span> <span class="attr">name</span>=<span class="string">"WSServiceImplService"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">types</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">xsd:schema</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://support.ws.integration.server.odb.product.uinnova.com/"</span> <span class="attr">schemaLocation</span>=<span class="string">"http://192.168.1.124:1533/ws/shi?xsd=1"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">types</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">message</span> <span class="attr">name</span>=<span class="string">"call"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">part</span> <span class="attr">name</span>=<span class="string">"parameters"</span> <span class="attr">element</span>=<span class="string">"tns:call"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">message</span> <span class="attr">name</span>=<span class="string">"callResponse"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">part</span> <span class="attr">name</span>=<span class="string">"parameters"</span> <span class="attr">element</span>=<span class="string">"tns:callResponse"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">portType</span> <span class="attr">name</span>=<span class="string">"WSServiceImpl"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">operation</span> <span class="attr">name</span>=<span class="string">"call"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">wsam:Action</span>=<span class="string">"http://support.ws.integration.server.odb.product.uinnova.com/WSServiceImpl/callRequest"</span> <span class="attr">message</span>=<span class="string">"tns:call"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">output</span> <span class="attr">wsam:Action</span>=<span class="string">"http://support.ws.integration.server.odb.product.uinnova.com/WSServiceImpl/callResponse"</span> <span class="attr">message</span>=<span class="string">"tns:callResponse"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">operation</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">portType</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">binding</span> <span class="attr">name</span>=<span class="string">"WSServiceImplPortBinding"</span> <span class="attr">type</span>=<span class="string">"tns:WSServiceImpl"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">soap:binding</span> <span class="attr">transport</span>=<span class="string">"http://schemas.xmlsoap.org/soap/http"</span> <span class="attr">style</span>=<span class="string">"document"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">operation</span> <span class="attr">name</span>=<span class="string">"call"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">soap:operation</span> <span class="attr">soapAction</span>=<span class="string">""</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">"literal"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">output</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">"literal"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">output</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">operation</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">binding</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">"WSServiceImplService"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">"WSServiceImplPort"</span> <span class="attr">binding</span>=<span class="string">"tns:WSServiceImplPortBinding"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">soap:address</span> <span class="attr">location</span>=<span class="string">"http://192.168.1.124:1533/ws/shi"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">port</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>调用</strong></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cc.hansam.java.net.ws.odb;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过wsimport生成的客户端代码调用webservice服务</div><div class="line"> * </div><div class="line"> * @author hansam 945210972@qq.com</div><div class="line"> * @date 2017年7月24日下午3:03:19</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> App &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">		WSServiceImplService service = <span class="keyword">new</span> WSServiceImplService();</div><div class="line"></div><div class="line">		WSServiceImpl po = service.getWSServiceImplPort();</div><div class="line"></div><div class="line">		String <span class="keyword">call</span> = po.<span class="keyword">call</span>(<span class="string">""</span>);</div><div class="line"></div><div class="line">		System.out.<span class="keyword">println</span>(<span class="keyword">call</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;使用wsimport生成客户端java类&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;wsimport -keep -p cc &lt;a href=&quot;http://192.168.1.124:1533/ws/shi?wsdl&quot; target=&quot;_b
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java Socket编程</title>
    <link href="http://www.hansam.cc/2017/07/22/Java-Sockett%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.hansam.cc/2017/07/22/Java-Sockett编程/</id>
    <published>2017-07-22T15:34:51.000Z</published>
    <updated>2017-07-22T16:23:16.276Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java</strong>最初是作为网络编程语言出现的，其对网络提供了高度的支持，而在网络编程中，使用最多的就是Socket。QQ、MSN都使用了Socket相关的技术。</p>
<hr>
<h3 id="一、计算机网络基础"><a href="#一、计算机网络基础" class="headerlink" title="一、计算机网络基础"></a>一、计算机网络基础</h3><h4 id="1-两台计算机间进行通讯需要以下三个条件"><a href="#1-两台计算机间进行通讯需要以下三个条件" class="headerlink" title="1. 两台计算机间进行通讯需要以下三个条件"></a>1. 两台计算机间进行通讯需要以下三个条件</h4><blockquote>
<p>ip地址、协议、端口号</p>
</blockquote>
<h4 id="2-TCP-IP协议"><a href="#2-TCP-IP协议" class="headerlink" title="2. TCP/IP协议"></a>2. TCP/IP协议</h4><blockquote>
<p>是以TCP和IP为基础的不同层次上多个协议的集合，也称TCP/IP协议族、或TCP/IP协议栈<br>TCP：Transmission Control Protocol 传输控制协议<br>IP：Internet Protocol 互联网协议</p>
</blockquote>
<h4 id="3-TCP-IP五层模型"><a href="#3-TCP-IP五层模型" class="headerlink" title="3. TCP/IP五层模型"></a>3. TCP/IP五层模型</h4><blockquote>
<p>应用层<br>运输层<br>网络层<br>数据链路层<br>物理层</p>
</blockquote>
<h4 id="4-IP地址"><a href="#4-IP地址" class="headerlink" title="4. IP地址"></a>4. IP地址</h4><blockquote>
<p>为实现网络中不同计算机之间的通信，每台计算机都必须有一个唯一的标识(32bit)。</p>
</blockquote>
<h4 id="5-端口"><a href="#5-端口" class="headerlink" title="5. 端口"></a>5. 端口</h4><blockquote>
<p>区分一台主机的多个不同应用程序，端口号范围为0-65535，其中0-1023位为系统保留。<br>如：HTTP：80FTP：21 Telnet：23<br>IP地址+端口号组成了所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点，是TCP和UDP的基础</p>
</blockquote>
<h4 id="6-Socket套接字"><a href="#6-Socket套接字" class="headerlink" title="6. Socket套接字"></a>6. Socket套接字</h4><blockquote>
<p>IP地址+端口,组合在一起才能构成唯一能识别的标识符套接字<br>Socket原理机制：<br>通信的两端都有Socket<br>网络通信其实就是Socket间的通信<br>数据在两个Socket间通过IO传输  </p>
</blockquote>
<h4 id="7-Java中的网络支持"><a href="#7-Java中的网络支持" class="headerlink" title="7. Java中的网络支持"></a>7. Java中的网络支持</h4><blockquote>
<p>针对网络通信的不同层次，Java提供了不同的API，其提供的网络功能有四大类：<br>InetAddress:用于标识网络上的硬件资源，主要是IP地址<br>URL：统一资源定位符，通过URL可以直接读取或写入网络上的数据<br>Sockets：使用TCP协议实现的网络通信Socket相关的类<br>Datagram:使用UDP协议，将数据保存在用户数据报中，通过网络进行通信。</p>
</blockquote>
<h3 id="二、InetAddress"><a href="#二、InetAddress" class="headerlink" title="二、InetAddress"></a>二、InetAddress</h3><blockquote>
<p>InetAddress类用于标识网络上的硬件资源，标识IP地址。<br>该类没有构造方法<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取本机的InetAddress实例 </span></div><div class="line">InetAddress address =InetAddress.getLocalHost(); </div><div class="line">address.getHostName();<span class="comment">//获取计算机名 </span></div><div class="line">address.getHostAddress();<span class="comment">//获取IP地址 </span></div><div class="line">byte[] <span class="built_in">bytes</span> = address.getAddress();<span class="comment">//获取字节数组形式的IP地址,以点分隔的四部分 </span></div><div class="line"> </div><div class="line"><span class="comment">//获取其他主机的InetAddress实例 </span></div><div class="line">InetAddress address2 =InetAddress.getByName(<span class="string">"其他主机名"</span>); </div><div class="line">InetAddress address3 =InetAddress.getByName(<span class="string">"IP地址"</span>);</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="三、URL类"><a href="#三、URL类" class="headerlink" title="三、URL类"></a>三、URL类</h3><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个URL的实例 </span></div><div class="line">URL baidu =<span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>); </div><div class="line">URL <span class="built_in">url</span> =<span class="keyword">new</span> URL(baidu,<span class="string">"/index.html?username=tom#test"</span>);<span class="comment">//？表示参数，#表示锚点 </span></div><div class="line"><span class="built_in">url</span>.getProtocol();<span class="comment">//获取协议 </span></div><div class="line"><span class="built_in">url</span>.getHost();<span class="comment">//获取主机 </span></div><div class="line"><span class="built_in">url</span>.getPort();<span class="comment">//如果没有指定端口号，根据协议不同使用默认端口。此时getPort()方法的返回值为 -1 </span></div><div class="line"><span class="built_in">url</span>.getPath();<span class="comment">//获取文件路径 </span></div><div class="line"><span class="built_in">url</span>.getFile();<span class="comment">//文件名，包括文件路径+参数 </span></div><div class="line"><span class="built_in">url</span>.getRef();<span class="comment">//相对路径，就是锚点，即#号后面的内容 </span></div><div class="line"><span class="built_in">url</span>.getQuery();<span class="comment">//查询字符串，即参数</span></div></pre></td></tr></table></figure>
<h4 id="使用URL读取网页内容"><a href="#使用URL读取网页内容" class="headerlink" title="使用URL读取网页内容"></a>使用URL读取网页内容</h4><blockquote>
<p>通过URL对象的openStream()方法可以得到指定资源的输入流，通过流能够读取或访问网页上的资源<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用URL读取网页内容 </span></div><div class="line"><span class="comment">//创建一个URL实例 </span></div><div class="line">URL url =new URL(<span class="string">"http://www.baidu.com"</span>); </div><div class="line">InputStream <span class="keyword">is</span> = url.openStream();<span class="comment">//通过openStream方法获取资源的字节输入流 </span></div><div class="line">InputStreamReader isr =newInputStreamReader(<span class="keyword">is</span>,<span class="string">"UTF-8"</span>);<span class="comment">//将字节输入流转换为字符输入流,如果不指定编码，中文可能会出现乱码 </span></div><div class="line">BufferedReader br =newBufferedReader(isr);<span class="comment">//为字符输入流添加缓冲，提高读取效率 </span></div><div class="line">String <span class="keyword">data</span> = br.readLine();<span class="comment">//读取数据 </span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">data</span>!=<span class="literal">null</span>)&#123; </div><div class="line">System.<span class="keyword">out</span>.println(<span class="keyword">data</span>);<span class="comment">//输出数据 </span></div><div class="line"><span class="keyword">data</span> = br.readerLine(); </div><div class="line">&#125; </div><div class="line">br.close(); </div><div class="line">isr.colose(); </div><div class="line"><span class="keyword">is</span>.close();</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="四、TCP编程"><a href="#四、TCP编程" class="headerlink" title="四、TCP编程"></a>四、TCP编程</h3><h4 id="1-TCP协议"><a href="#1-TCP协议" class="headerlink" title="1. TCP协议"></a>1. TCP协议</h4><blockquote>
<p>是面向连接的、可靠的、有序的、以字节流的方式发送数据，通过三次握手方式建立连接，形成传输数据的通道，在连接中进行大量数据的传输，效率会稍低。</p>
</blockquote>
<h4 id="2-Java中基于TCP协议实现网络通信的类"><a href="#2-Java中基于TCP协议实现网络通信的类" class="headerlink" title="2. Java中基于TCP协议实现网络通信的类"></a>2. Java中基于TCP协议实现网络通信的类</h4><blockquote>
<p>客户端的Socket类<br>服务器端的ServerSocket类<br><img src="http://s9.51cto.com/wyfs02/M01/72/D1/wKioL1XuRtDx8IG2AACLNnarS5A899.jpg-wh_651x-s_3157864048.jpg" alt="socket通信模型"></p>
</blockquote>
<h4 id="3-Socket通信的步骤"><a href="#3-Socket通信的步骤" class="headerlink" title="3. Socket通信的步骤"></a>3. Socket通信的步骤</h4><blockquote>
<p>① 创建ServerSocket和Socket<br>② 打开连接到Socket的输入/输出流<br>③ 按照协议对Socket进行读/写操作<br>④ 关闭输入输出流、关闭Socket</p>
</blockquote>
<h4 id="4-服务器端"><a href="#4-服务器端" class="headerlink" title="4. 服务器端"></a>4. 服务器端</h4><blockquote>
<p>① 创建ServerSocket对象，绑定监听端口<br>② 通过accept()方法监听客户端请求<br>③ 连接建立后，通过输入流读取客户端发送的请求信息<br>④ 通过输出流向客户端发送乡音信息<br>⑤ 关闭相关资源<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> 基于TCP协议的Socket通信，实现用户登录，服务端 </div><div class="line">*/ </div><div class="line"><span class="comment">//1、创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并监听此端口 </span></div><div class="line">ServerSocket serverSocket =newServerSocket(<span class="number">10086</span>);<span class="comment">//1024-65535的某个端口 </span></div><div class="line"><span class="comment">//2、调用accept()方法开始监听，等待客户端的连接 </span></div><div class="line">Socket socket = serverSocket.accept(); </div><div class="line"><span class="comment">//3、获取输入流，并读取客户端信息 </span></div><div class="line">InputStream is = socket.getInputStream(); </div><div class="line">InputStreamReader isr =newInputStreamReader(is); </div><div class="line">BufferedReader br =newBufferedReader(isr); </div><div class="line"><span class="keyword">String</span> info =null; </div><div class="line"><span class="built_in">while</span>((info=br.readLine())!=null)&#123; </div><div class="line">System.out.<span class="built_in">println</span>(<span class="string">"我是服务器，客户端说："</span>+info)； </div><div class="line">&#125; </div><div class="line">socket.shutdownInput();<span class="comment">//关闭输入流 </span></div><div class="line"><span class="comment">//4、获取输出流，响应客户端的请求 </span></div><div class="line">OutputStream os = socket.getOutputStream(); </div><div class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(os); </div><div class="line">pw.<span class="built_in">write</span>(<span class="string">"欢迎您！"</span>); </div><div class="line">pw.<span class="built_in">flush</span>(); </div><div class="line"> </div><div class="line"><span class="comment">//5、关闭资源 </span></div><div class="line">pw.<span class="built_in">close</span>(); </div><div class="line">os.<span class="built_in">close</span>(); </div><div class="line">br.<span class="built_in">close</span>(); </div><div class="line">isr.<span class="built_in">close</span>(); </div><div class="line">is.<span class="built_in">close</span>(); </div><div class="line">socket.<span class="built_in">close</span>(); </div><div class="line">serverSocket.<span class="built_in">close</span>();</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="5-客户端"><a href="#5-客户端" class="headerlink" title="5. 客户端"></a>5. 客户端</h4><blockquote>
<p>① 创建Socket对象，指明需要连接的服务器的地址和端口号<br>② 连接建立后，通过输出流想服务器端发送请求信息<br>③ 通过输入流获取服务器响应的信息<br>④ 关闭响应资源<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//客户端 </span></div><div class="line"><span class="comment">//1、创建客户端Socket，指定服务器地址和端口 </span></div><div class="line">Socket socket =newSocket(<span class="string">"localhost"</span>,<span class="number">10086</span>); </div><div class="line"><span class="comment">//2、获取输出流，向服务器端发送信息 </span></div><div class="line">OutputStream os = socket.getOutputStream();<span class="comment">//字节输出流 </span></div><div class="line">PrintWriter pw =newPrintWriter(os);<span class="comment">//将输出流包装成打印流 </span></div><div class="line">pw.<span class="built_in">write</span>(<span class="string">"用户名：admin；密码：123"</span>); </div><div class="line">pw.<span class="built_in">flush</span>(); </div><div class="line">socket.shutdownOutput(); </div><div class="line"><span class="comment">//3、获取输入流，并读取服务器端的响应信息 </span></div><div class="line">InputStream is = socket.getInputStream(); </div><div class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is)); </div><div class="line"><span class="keyword">String</span> info = null; </div><div class="line"><span class="built_in">while</span>((info=br.readLine())!null)&#123; </div><div class="line"> System.out.<span class="built_in">println</span>(<span class="string">"我是客户端，服务器说："</span>+info); </div><div class="line">&#125; </div><div class="line"> </div><div class="line"><span class="comment">//4、关闭资源 </span></div><div class="line">br.<span class="built_in">close</span>(); </div><div class="line">is.<span class="built_in">close</span>(); </div><div class="line">pw.<span class="built_in">close</span>(); </div><div class="line">os.<span class="built_in">close</span>(); </div><div class="line">socket.<span class="built_in">close</span>();</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="6-应用多线程实现服务器与多客户端之间的通信"><a href="#6-应用多线程实现服务器与多客户端之间的通信" class="headerlink" title="6. 应用多线程实现服务器与多客户端之间的通信"></a>6. 应用多线程实现服务器与多客户端之间的通信</h4><blockquote>
<p>① 服务器端创建ServerSocket，循环调用accept()等待客户端连接<br>② 客户端创建一个socket并请求和服务器端连接<br>③ 服务器端接受苦读段请求，创建socket与该客户建立专线连接<br>④ 建立连接的两个socket在一个单独的线程上对话<br>⑤ 服务器端继续等待新的连接<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//服务器线程处理 </span></div><div class="line"><span class="comment">//和本线程相关的socket </span></div><div class="line">Socket socket =<span class="keyword">null</span>; </div><div class="line"><span class="comment">// </span></div><div class="line"><span class="keyword">public</span> serverThread(Socket socket)&#123; </div><div class="line"><span class="keyword">this</span>.socket = socket; </div><div class="line">&#125; </div><div class="line"> </div><div class="line">publicvoid run()&#123; </div><div class="line"><span class="comment">//服务器处理代码 </span></div><div class="line">&#125; </div><div class="line"> </div><div class="line"><span class="comment">//============================================ </span></div><div class="line"><span class="comment">//服务器代码 </span></div><div class="line">ServerSocket serverSocket =newServerSocket(<span class="number">10086</span>); </div><div class="line">Socket socket =<span class="keyword">null</span>; </div><div class="line"><span class="keyword">int</span> <span class="keyword">count</span> =<span class="number">0</span>;<span class="comment">//记录客户端的数量 </span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; </div><div class="line">socket = serverScoket.accept(); </div><div class="line">ServerThread serverThread =newServerThread(socket); </div><div class="line"> serverThread.start(); </div><div class="line"> <span class="keyword">count</span>++; </div><div class="line">System.out.<span class="keyword">println</span>(<span class="string">"客户端连接的数量："</span>+<span class="keyword">count</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="五、UDP编程"><a href="#五、UDP编程" class="headerlink" title="五、UDP编程"></a>五、UDP编程</h3><blockquote>
<p>UDP协议（用户数据报协议）是无连接的、不可靠的、无序的,速度快<br>进行数据传输时，首先将要传输的数据定义成数据报（Datagram），大小限制在64k，在数据报中指明数据所要达到的Socket（主机地址和端口号），然后再将数据报发送出去。<br>DatagramPacket类:表示数据报包<br>DatagramSocket类：进行端到端通信的类</p>
</blockquote>
<h4 id="1-服务器端实现步骤"><a href="#1-服务器端实现步骤" class="headerlink" title="1. 服务器端实现步骤"></a>1. 服务器端实现步骤</h4><blockquote>
<p>① 创建DatagramSocket，指定端口号<br>② 创建DatagramPacket<br>③ 接受客户端发送的数据信息<br>④ 读取数据<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//服务器端，实现基于UDP的用户登录 </span></div><div class="line"><span class="comment">//1、创建服务器端DatagramSocket，指定端口 </span></div><div class="line">DatagramSocket socket =<span class="keyword">new</span> <span class="type">datagramSocket</span>(<span class="number">10010</span>); </div><div class="line"><span class="comment">//2、创建数据报，用于接受客户端发送的数据 </span></div><div class="line">byte[] data =<span class="keyword">new</span><span class="type">byte</span>[<span class="number">1024</span>];<span class="comment">// </span></div><div class="line">DatagramPacket packet =<span class="keyword">new</span><span class="type">DatagramPacket</span>(data,data.length); </div><div class="line"><span class="comment">//3、接受客户端发送的数据 </span></div><div class="line">socket.receive(packet);<span class="comment">//此方法在接受数据报之前会一致阻塞 </span></div><div class="line"><span class="comment">//4、读取数据 </span></div><div class="line"><span class="keyword">String</span> info =<span class="keyword">new</span><span class="type">String</span>(data,o,data.length); </div><div class="line">System.out.println(<span class="string">"我是服务器，客户端告诉我"</span>+info); </div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//========================================================= </span></div><div class="line"><span class="comment">//向客户端响应数据 </span></div><div class="line"><span class="comment">//1、定义客户端的地址、端口号、数据 </span></div><div class="line">InetAddress address = packet.getAddress(); </div><div class="line">int port = packet.getPort(); </div><div class="line">byte[] data2 = <span class="string">"欢迎您！"</span>.geyBytes(); </div><div class="line"><span class="comment">//2、创建数据报，包含响应的数据信息 </span></div><div class="line">DatagramPacket packet2 = <span class="keyword">new</span> <span class="type">DatagramPacket</span>(data2,data2.length,address,port); </div><div class="line"><span class="comment">//3、响应客户端 </span></div><div class="line">socket.send(packet2); </div><div class="line"><span class="comment">//4、关闭资源 </span></div><div class="line">socket.close();</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2-客户端实现步骤"><a href="#2-客户端实现步骤" class="headerlink" title="2. 客户端实现步骤"></a>2. 客户端实现步骤</h4><blockquote>
<p>① 定义发送信息<br>② 创建DatagramPacket，包含将要发送的信息<br>③ 创建DatagramSocket<br>④ 发送数据<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//客户端 </span></div><div class="line"><span class="comment">//1、定义服务器的地址、端口号、数据 </span></div><div class="line">InetAddress address =InetAddress.getByName(<span class="string">"localhost"</span>); </div><div class="line"><span class="keyword">int</span> port =<span class="number">10010</span>; </div><div class="line"><span class="keyword">byte</span>[] data =<span class="string">"用户名：admin;密码：123"</span>.getBytes(); </div><div class="line"><span class="comment">//2、创建数据报，包含发送的数据信息 </span></div><div class="line">DatagramPacket packet = newDatagramPacket(data,data,length,address,port); </div><div class="line"><span class="comment">//3、创建DatagramSocket对象 </span></div><div class="line">DatagramSocket socket =newDatagramSocket(); </div><div class="line"><span class="comment">//4、向服务器发送数据 </span></div><div class="line">socket.send(packet); </div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//接受服务器端响应数据 </span></div><div class="line"><span class="comment">//====================================== </span></div><div class="line"><span class="comment">//1、创建数据报，用于接受服务器端响应数据 </span></div><div class="line"><span class="keyword">byte</span>[] data2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; </div><div class="line">DatagramPacket packet2 = <span class="keyword">new</span> DatagramPacket(data2,data2.length); </div><div class="line"><span class="comment">//2、接受服务器响应的数据 </span></div><div class="line">socket.receive(packet2); </div><div class="line"><span class="keyword">String</span> raply = <span class="keyword">new</span> <span class="keyword">String</span>(data2,<span class="number">0</span>,packet2.getLenth()); </div><div class="line">System.out.<span class="built_in">println</span>(<span class="string">"我是客户端，服务器说："</span>+reply); </div><div class="line"><span class="comment">//4、关闭资源 </span></div><div class="line">socket.<span class="built_in">close</span>();</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="六、注意问题"><a href="#六、注意问题" class="headerlink" title="六、注意问题"></a>六、注意问题</h3><h4 id="1-多线程的优先级问题"><a href="#1-多线程的优先级问题" class="headerlink" title="1. 多线程的优先级问题"></a>1. 多线程的优先级问题</h4><blockquote>
<p>根据实际的经验，适当的降低优先级，否侧可能会有程序运行效率低的情况</p>
</blockquote>
<h4 id="2-是否关闭输出流和输入流"><a href="#2-是否关闭输出流和输入流" class="headerlink" title="2. 是否关闭输出流和输入流"></a>2. 是否关闭输出流和输入流</h4><blockquote>
<p>对于同一个socket，如果关闭了输出流，则与该输出流关联的socket也会被关闭，所以一般不用关闭流，直接关闭socket即可</p>
</blockquote>
<h4 id="3-使用TCP通信传输对象，IO中序列化部分"><a href="#3-使用TCP通信传输对象，IO中序列化部分" class="headerlink" title="3. 使用TCP通信传输对象，IO中序列化部分"></a>3. 使用TCP通信传输对象，IO中序列化部分</h4><h4 id="4-Socket编程传递文件，IO流部分"><a href="#4-Socket编程传递文件，IO流部分" class="headerlink" title="4. Socket编程传递文件，IO流部分"></a>4. Socket编程传递文件，IO流部分</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt;最初是作为网络编程语言出现的，其对网络提供了高度的支持，而在网络编程中，使用最多的就是Socket。QQ、MSN都使用了Socket相关的技术。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、计算机网络基础&quot;&gt;&lt;a href=&quot;#一、计算机
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java特殊注释</title>
    <link href="http://www.hansam.cc/2017/07/18/java%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A/"/>
    <id>http://www.hansam.cc/2017/07/18/java特殊注释/</id>
    <published>2017-07-18T15:01:13.000Z</published>
    <updated>2017-07-18T15:27:05.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java中的特殊注释："><a href="#java中的特殊注释：" class="headerlink" title="java中的特殊注释："></a>java中的特殊注释：</h2><hr>
<h3 id="1-TODO"><a href="#1-TODO" class="headerlink" title="1. TODO"></a>1. TODO</h3><blockquote>
<p>表示需要实现，但目前还未实现的功能</p>
</blockquote>
<h3 id="2-XXX"><a href="#2-XXX" class="headerlink" title="2. XXX"></a>2. XXX</h3><blockquote>
<p>勉强可以工作，但是性能差等原因</p>
</blockquote>
<h3 id="3-FIXME"><a href="#3-FIXME" class="headerlink" title="3. FIXME"></a>3. FIXME</h3><blockquote>
<p>代码是错误的，不能工作，需要修复</p>
</blockquote>
<hr>
<p><strong>TODO: + 说明：</strong></p>
<blockquote>
<p>如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</p>
</blockquote>
<p><strong>FIXME: + 说明：</strong></p>
<blockquote>
<p>如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p>
</blockquote>
<p><strong>XXX: + 说明：</strong></p>
<blockquote>
<p>如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</p>
</blockquote>
<p><strong>eclipse中特殊的注释：</strong></p>
<blockquote>
<p>在eclipse中，TODO、FIXME和XXX都会被eclipse的task视图所收集。在项目发布前，检查一下task视图是一个很好的习惯。此外，在eclipse中，我们可自定义自己的特殊注释标签。如在Java中，进入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A[Windows] --&gt; B[Java] </div><div class="line">B --&gt; C[Compiler]</div><div class="line">C --&gt; D[Task Tags]</div></pre></td></tr></table></figure></p>
<p>窗口即可添加特殊标签，默认只有TODO、FIXME和XXX。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java中的特殊注释：&quot;&gt;&lt;a href=&quot;#java中的特殊注释：&quot; class=&quot;headerlink&quot; title=&quot;java中的特殊注释：&quot;&gt;&lt;/a&gt;java中的特殊注释：&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-TODO&quot;&gt;&lt;a href=&quot;#1-TODO
    
    </summary>
    
    
      <category term="笔记" scheme="http://www.hansam.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>fastjson基础测试</title>
    <link href="http://www.hansam.cc/2017/07/17/fastjson%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.hansam.cc/2017/07/17/fastjson基础测试/</id>
    <published>2017-07-17T14:57:53.000Z</published>
    <updated>2017-07-18T14:56:12.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fastjson使用测试"><a href="#fastjson使用测试" class="headerlink" title="fastjson使用测试"></a>fastjson使用测试</h3><hr>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cc.hansam.mystudy.json;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author hansam 945210972@qq.com</div><div class="line"> * @date 2017年7月17日下午4:59:16</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class JSONTest &#123;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		Person person = <span class="keyword">new</span> Person();</div><div class="line">		person.setId(<span class="number">1</span>);</div><div class="line">		person.setName(<span class="string">"shi"</span>);</div><div class="line">		person.setAge(<span class="number">22</span>);</div><div class="line">		person.setSex(<span class="string">"male"</span>);</div><div class="line"></div><div class="line">		<span class="comment">// object to jsonstring</span></div><div class="line">		<span class="keyword">String</span> jString = JSON.toJSONString(person);</div><div class="line">		System.out.<span class="built_in">println</span>(jString);</div><div class="line">		</div><div class="line">		<span class="comment">// jsonstring parse to map</span></div><div class="line">		Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = (Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;)JSON.parse(jString);</div><div class="line">		System.out.<span class="built_in">println</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"name"</span>));</div><div class="line"></div><div class="line">		</div><div class="line">		<span class="comment">// jsonstring pare to object</span></div><div class="line">		<span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"&#123;\"age\":22,\"id\":1,\"name\":\"shi\",\"sex\":\"male\",\"dea\":\"male\",\"sasa\":\"male\"&#125;"</span>;</div><div class="line">		Person p = JSON.parseObject(<span class="built_in">str</span>, Person.class);</div><div class="line">		System.out.<span class="built_in">println</span>(p);</div><div class="line">		</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * fastjson 转换key不区分大小写，转换没有明确的对应关系（多对多）</div><div class="line">		 */</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结论：</p>
<blockquote>
<p>fastjson 转换key不区分大小写，转换没有明确的对应关系（多对多）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;fastjson使用测试&quot;&gt;&lt;a href=&quot;#fastjson使用测试&quot; class=&quot;headerlink&quot; title=&quot;fastjson使用测试&quot;&gt;&lt;/a&gt;fastjson使用测试&lt;/h3&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight pro
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
      <category term="json" scheme="http://www.hansam.cc/tags/json/"/>
    
  </entry>
  
  <entry>
    <title> 广告投放方式：CPC、CPM、CPA、CPS、CPT</title>
    <link href="http://www.hansam.cc/2017/07/09/%E5%B9%BF%E5%91%8A%E6%8A%95%E6%94%BE%E6%96%B9%E5%BC%8F%EF%BC%9ACPC%E3%80%81CPM%E3%80%81CPA%E3%80%81CPS%E3%80%81CPT/"/>
    <id>http://www.hansam.cc/2017/07/09/广告投放方式：CPC、CPM、CPA、CPS、CPT/</id>
    <published>2017-07-09T10:17:23.000Z</published>
    <updated>2017-07-09T13:36:37.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPC（按点击付费）"><a href="#CPC（按点击付费）" class="headerlink" title="CPC（按点击付费）"></a>CPC（按点击付费）</h3><blockquote>
<p>CPC—英文全称Cost PerClick。CPC是一种点击付费广告，根据广告被点击的次数收费。如关键词广告一般采用这种定价模式，比较典型的有Google的AdSensefor Content、百度联盟的百度竞价广告以及淘宝的直通车广告。</p>
</blockquote>
<h3 id="CPM（按展示付费）"><a href="#CPM（按展示付费）" class="headerlink" title="CPM（按展示付费）"></a>CPM（按展示付费）</h3><blockquote>
<p>CPM—英文全称Cost Per Mille 或者是Cost PerThousandImpression。CPM是一种展示付费广告，只要展示了广告主的广告内容，广告主就为此付费。这种广告的效果不是很好，但是却能给有一定流量的网站、博客带来稳定的收入。</p>
</blockquote>
<h3 id="CPA（按行为付费）"><a href="#CPA（按行为付费）" class="headerlink" title="CPA（按行为付费）"></a>CPA（按行为付费）</h3><blockquote>
<p>CPA—英文全称Cost PerAction。CPA是一种按广告投放实际效果计价方式的广告，即按回应的有效问卷或定单来计费，而不限广告投放量。CPA的计价方式对于网站而言有一定的风险，但若广告投放成功，其收益也比CPM的计价方式要大得多。</p>
</blockquote>
<h3 id="CPS（按销售付费）"><a href="#CPS（按销售付费）" class="headerlink" title="CPS（按销售付费）"></a>CPS（按销售付费）</h3><blockquote>
<p>CPS—英文全称Cost PerSales。CPS是一种以实际销售产品数量来计算广告费用的广告，这种广告更多的适合购物类、导购类、网址导航类的网站，需要精准的流量才能带来转化。凡客的网站联盟是这种广告形式的典型代表。</p>
</blockquote>
<h3 id="CPT（按-时长付费）"><a href="#CPT（按-时长付费）" class="headerlink" title="CPT（按 时长付费）"></a>CPT（按 时长付费）</h3><blockquote>
<p>CPT—英文全称Cost PerTime。CPT是一种以时间来计费的广告，国内很多的网站都是按照“一个月多少钱”这种固定收费模式来收费的，这种广告形式很粗糙，无法保障客户的利益。但是CPT的确是一种很省心的广告，能给你的网站、博客带来稳定的收入。<br>阿里妈妈的按周计费广告和门户网站的包月广告都属于这种CPT广告。<br>相比而言，CPM和CPT对网站有利，而CPC、CPA、CPS则对广告主有利。目前比较流行的计价方式是CPM和CPC，最为流行的则为CPM。</p>
</blockquote>
<h3 id="其他相关内容："><a href="#其他相关内容：" class="headerlink" title="其他相关内容："></a>其他相关内容：</h3><p>1、CPM<br>　　收费最科学的办法是按照有多少人看到你的广告来收费。按访问人次收费已经成为移动广告平台的惯例。CPM（千人成本）指的是广告投放过程中，听到或者看到某广告的每一人平均分担到多少广告成本。传统媒介多采用这种计价方式。在移动广告平台上，CPM取决于“印象”尺度，通常理解为一个人的眼睛在一段固定的时间内注视一个广告的次数。比如说一个内置广告横幅的单价是1元/CPM的话，意味着每一千个人次看到这个Ban-ner的话就收1元，如此类推，10，000人次访问的主页就是10元。至于每CPM的收费究竟是多少，要根据以手机应用的热门程度（即浏览人数）划分价格等级，采取固定费率。国际惯例是每CPM收费从5美元至200美元不等。<br>2、CPC<br>　　以每点击一次计费。这样的方法加上点击率限制可以加强作弊的难度，而且是宣传的最优方式。但是，此类方法就有不少人觉得不公平，比如，虽然浏览者没有点击，但是他已经看到了广告，对于这些看到广告却没有点击的流量来说，广告成了白忙活。有很多手机应用不愿意做这样的广告，据说，是因为传统媒体从来都没有这样干过。<br>3、CPA<br>　　CPA计价方式是指按广告投放实际效果，即按回应的有效问卷或定单来计费，而不限广告投放量。CPA的计价方式对于网站而言有一定的风险，但若广告投放成功，其收益也比CPM的计价方式要大得多。据我所知7天酒店在投放网络广告的时候，有一部分就是这么干的，按照每注册一个会员，给网站付20元。说道收费方式CPM、CPC 、CPA三种收费方式只能比较出哪个更适合你而已。<br>　　无论采用CPM、CPC还是CPA，广告主都可以根据自身产品特性进行选择，这和传统互联网广告是一样的。由于电商行业的快速发展，目前移动广告平台还出现了CPS（按每次购买进行计费）的收费方式，但普遍效果还不够好，原因更多在于移动支付方面还有诸多不便的地方。<br>　　目前国内绝大部分移动广告平台都支持CPM、CPC、CPA计费，在选择移动广告投放时，广告主可更多考虑移动广告平台的稳定性和媒介资源深度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPC（按点击付费）&quot;&gt;&lt;a href=&quot;#CPC（按点击付费）&quot; class=&quot;headerlink&quot; title=&quot;CPC（按点击付费）&quot;&gt;&lt;/a&gt;CPC（按点击付费）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;CPC—英文全称Cost PerClick。CPC
    
    </summary>
    
    
      <category term="百科" scheme="http://www.hansam.cc/tags/%E7%99%BE%E7%A7%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC项目JSP取不到ModelAndView的数据解决</title>
    <link href="http://www.hansam.cc/2017/07/09/SpringMVC%E9%A1%B9%E7%9B%AEJSP%E5%8F%96%E4%B8%8D%E5%88%B0ModelAndView%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%86%B3/"/>
    <id>http://www.hansam.cc/2017/07/09/SpringMVC项目JSP取不到ModelAndView的数据解决/</id>
    <published>2017-07-09T10:11:36.000Z</published>
    <updated>2017-07-09T10:25:59.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用maven构建的springmvc项目EL表达式取不到值-不管是用-msg-还是用JSTL的-都不行"><a href="#使用maven构建的springmvc项目EL表达式取不到值-不管是用-msg-还是用JSTL的-都不行" class="headerlink" title="使用maven构建的springmvc项目EL表达式取不到值,不管是用 ${msg}还是用JSTL的 都不行"></a>使用maven构建的springmvc项目EL表达式取不到值,不管是用 ${msg}还是用JSTL的<c:out value="${msg}"> 都不行</c:out></h3><p>我是用maven自动生成的web.xml文件 如下：</p>
<pre><code>&lt;!DOCTYPE web-app PUBLIC  
&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;  
&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;  

&lt;web-app&gt;  

&lt;/web-app&gt;  
</code></pre><p>但这样的文件不行，需要改成</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  

&lt;web-app&gt;

&lt;/web-app&gt;  
</code></pre><p>重启就OK了，现在上面的两种方法都支持了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用maven构建的springmvc项目EL表达式取不到值-不管是用-msg-还是用JSTL的-都不行&quot;&gt;&lt;a href=&quot;#使用maven构建的springmvc项目EL表达式取不到值-不管是用-msg-还是用JSTL的-都不行&quot; class=&quot;headerl
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java资源绑定（ResourceBundle）示例</title>
    <link href="http://www.hansam.cc/2017/07/04/Java%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%EF%BC%88ResourceBundle%EF%BC%89%E7%A4%BA%E4%BE%8B/"/>
    <id>http://www.hansam.cc/2017/07/04/Java资源绑定（ResourceBundle）示例/</id>
    <published>2017-07-04T15:42:00.000Z</published>
    <updated>2017-07-09T13:30:25.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java-util-ResourceBundle"><a href="#java-util-ResourceBundle" class="headerlink" title="java.util.ResourceBundle"></a>java.util.ResourceBundle</h3><blockquote>
<p>是用于国际化（多语言）的库。它能够根据为系统配置的默认区域设置返回消息。当开发适用于世界各地使用的系统时，就可以使用这样的功能。</p>
</blockquote>
<h3 id="1-它是如何工作的？"><a href="#1-它是如何工作的？" class="headerlink" title="1.它是如何工作的？"></a>1.它是如何工作的？</h3><blockquote>
<p>库是基于在属性命名中使用的区域设置和名称后缀读取属性文件。例如，考虑一个名为MyLabels_en_US.properties的标签文件。当Locale设置表示US-English的en_US时，此文件由ResourceBundle程序读取。<br>区域设置表示具有其属性的区域或位置。Locale通常用于使用我们的应用程序维护有关客户端的详细信息。 区域设置包含要用于相应位置的位置和语言的属性。 因此，Locale通过确定用户所属的位置来帮助ResourceBundle选择正确的标签文件。</p>
</blockquote>
<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h3><pre><code>让我们看看下面的例子，以更清楚地说明这个问题：
MyLabels_en_US.properties 文件有以下内容 -
how_are_you = How are you?
Java
MyLabels_ms_MY.properties 文件有以下内容 -
how_are_you = apa khabar
Java
完整的程序代码如下 -
</code></pre><p>

<pre><code>import java.util.Locale;
import java.util.ResourceBundle;

public class Application {

    public static void main(String[] args) {

        // en_US
        System.out.println(&quot;Current Locale: &quot; + Locale.getDefault());
        ResourceBundle mybundle = ResourceBundle.getBundle(&quot;MyLabels&quot;);

        // read MyLabels_en_US.properties
        System.out.println(&quot;Say how are you in US English: &quot; + mybundle.getString(&quot;how_are_you&quot;));

        Locale.setDefault(new Locale(&quot;ms&quot; &quot;MY&quot;));

        // read MyLabels_ms_MY.properties
        System.out.println(&quot;Current Locale: &quot; + Locale.getDefault());
        mybundle = ResourceBundle.getBundle(&quot;MyLabels&quot;);
        System.out.println(&quot;Say how are you in Malaysian Malaya language: &quot; + mybundle.getString(&quot;how_are_you&quot;));

    }

}
</code></pre></p><p>Java在执行此代码时，得到以下输出：</p>
<pre><code>Current Locale: en_US
Say how are you in US English: How are you?
Current Locale: ms_MY
Say how are you in Malaysian Malaya language: apa khabar
Java
</code></pre><p>在输出中可以看到，取决于为Locale集设置的默认值。此实用程序主要用于Web应用程序，其中Web浏览器有助于了解远程用户的区域设置。这使得尽可能以特定语言显示网站成为可能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java-util-ResourceBundle&quot;&gt;&lt;a href=&quot;#java-util-ResourceBundle&quot; class=&quot;headerlink&quot; title=&quot;java.util.ResourceBundle&quot;&gt;&lt;/a&gt;java.util.Reso
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中堆内存和栈内存详解</title>
    <link href="http://www.hansam.cc/2017/07/04/Java%E4%B8%AD%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.hansam.cc/2017/07/04/Java中堆内存和栈内存详解/</id>
    <published>2017-07-04T15:27:43.000Z</published>
    <updated>2017-07-09T13:47:30.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构的栈和堆"><a href="#数据结构的栈和堆" class="headerlink" title="数据结构的栈和堆"></a>数据结构的栈和堆</h2><hr>
<blockquote>
<p>首先在数据结构上要知道堆栈，尽管我们这么称呼它，但实际上堆栈是两种数据结构：堆和栈。</p>
</blockquote>
<p><strong>堆和栈都是一种数据项按序排列的数据结构</strong></p>
<p><strong>栈就像装数据的桶或箱子</strong></p>
<blockquote>
<p>我们先从大家比较熟悉的栈说起吧，它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我们首先要移开压在它上面的物体（放入的比较晚的物体）。</p>
</blockquote>
<p><strong>堆像一棵倒过来的树</strong></p>
<blockquote>
<p>而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>
</blockquote>
<h2 id="Java中内存分配策略及堆和栈的比较"><a href="#Java中内存分配策略及堆和栈的比较" class="headerlink" title="Java中内存分配策略及堆和栈的比较"></a>Java中内存分配策略及堆和栈的比较</h2><h3 id="1-内存分配策略"><a href="#1-内存分配策略" class="headerlink" title="1 内存分配策略"></a>1 内存分配策略</h3><p>　　按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的. </p>
<p>　　静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求. </p>
<p>　　栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。 </p>
<p>　　静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放. </p>
<h3 id="2-堆和栈的比较"><a href="#2-堆和栈的比较" class="headerlink" title="2 堆和栈的比较"></a>2 堆和栈的比较</h3><p>　　上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈: </p>
<p>　　从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的: </p>
<p>　　在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时. </p>
<p>　　堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~). </p>
<h3 id="3-JVM中的堆和栈"><a href="#3-JVM中的堆和栈" class="headerlink" title="3 JVM中的堆和栈"></a>3 JVM中的堆和栈</h3><p>　　JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 </p>
<p>　　我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的. </p>
<p>　　从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。 </p>
<p>　　每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。 </p>
<p>　　</p>
<h2 id="Java-中的堆和栈"><a href="#Java-中的堆和栈" class="headerlink" title="Java 中的堆和栈"></a>Java 中的堆和栈</h2><p>　　Java把内存划分成两种：一种是栈内存，一种是堆内存。 </p>
<p>　　在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 </p>
<p>　　当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 </p>
<p>　　堆内存用来存放由new创建的对象和数组。 </p>
<p>　　在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 </p>
<p>　　在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 </p>
<p>　　引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 </p>
<h3 id="具体的说："><a href="#具体的说：" class="headerlink" title="具体的说："></a>具体的说：</h3><p>　　</p>
<blockquote>
<p>　　栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 </p>
<p>　　Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p>
<p>　　栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int,<br>short, long, byte, float, double, boolean, char)和对象句柄。</p>
</blockquote>
<p>　　栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： </p>
<p>　　int a = 3; </p>
<p>　　int b = 3; </p>
<p>　　编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据结构的栈和堆&quot;&gt;&lt;a href=&quot;#数据结构的栈和堆&quot; class=&quot;headerlink&quot; title=&quot;数据结构的栈和堆&quot;&gt;&lt;/a&gt;数据结构的栈和堆&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;首先在数据结构上要知道堆栈，尽管我们这么称呼它，但实际上
    
    </summary>
    
    
      <category term="java" scheme="http://www.hansam.cc/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>my-first-blog</title>
    <link href="http://www.hansam.cc/2017/05/02/my-first-blog/"/>
    <id>http://www.hansam.cc/2017/05/02/my-first-blog/</id>
    <published>2017-05-02T01:13:21.000Z</published>
    <updated>2017-07-09T10:07:31.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是我的第一篇博客"><a href="#这是我的第一篇博客" class="headerlink" title="这是我的第一篇博客"></a>这是我的第一篇博客</h2><hr>
<blockquote>
<p>我此时正在图书馆，准备毕业答辩的相关事宜。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这是我的第一篇博客&quot;&gt;&lt;a href=&quot;#这是我的第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;这是我的第一篇博客&quot;&gt;&lt;/a&gt;这是我的第一篇博客&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我此时正在图书馆，准备毕业答辩的相关事宜。&lt;/p
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.hansam.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
